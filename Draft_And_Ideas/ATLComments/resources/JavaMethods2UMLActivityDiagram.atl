-- @atlcompiler atl2010

-- @nsURI UML=http://www.eclipse.org/uml2/4.0.0/UML
-- @nsURI JAVA=http://www.eclipse.org/MoDisco/Java/0.2.incubation/java

-- ******************************************************************************
-- Copyright (c) 2013 INRIA. 
-- All rights reserved. This program and the accompanying materials 
-- are made available under the terms of the Eclipse Public License v1.0 
-- which accompanies this distribution, and is available at
-- http://www.eclipse.org/legal/epl-v10.html
-- 
-- Contributors: 
-- 	INRIA - Initial implementation
--  authors: Guillaume Doux (guillaume.doux at inria.fr) 
--			 Matthieu Allon (matthieu.allon at gmail.com)
-- Initially developed in the context of ARTIST EU project www.artist-project.eu
-- ******************************************************************************

module JavaMethods2UMLActivityDiagram;

create OUT: UML from IN: JAVA;

uses java2UMLActivityHelpers;

rule JModelRootToUmlModelRoot {
	from 
		jModelRoot : JAVA!Model
	to 
		umlModelRoot : UML!Model (
			name <- 'root model', 			
			packagedElement <- jModelRoot.allAbstractMethodDeclaration
								->including(cd)
								-> append(thisModule.createExternalsModel(jModelRoot))	
		),
		cd	:	UML!Package(
			name <- 'Associated Classifiers',
			packagedElement <- thisModule.allTypes 
									-> union(UML!Dependency.allInstancesFrom('OUT'))
		)
}

---Create 'external' model
unique lazy rule createExternalsModel{
	from 
		jModel : JAVA!Model
	to 
		umlModel : UML!Package(
			name <- 'externals',
			packagedElement <- jModel.getExternalElements
								-> select(elem | elem.oclIsTypeOf(JAVA!Package))
								-> select(elem | elem.isAnExternalPackage)
		)
}

---Package only for the external lib.
rule JPackageToUmlPackage {
	from 
		jPackage : JAVA!Package(
			jPackage.isAnExternalPackage
		)
	to 
		umlPackage : UML!Package (
				name <- jPackage.name, 
				nestedPackage <- jPackage.ownedPackages 
									-> select(elem | elem.isAnExternalPackage),
				packagedElement <- jPackage.ownedElements 
										-> select(c | c.oclIsKindOf(JAVA!ClassDeclaration) 
														or c.oclIsKindOf(JAVA!InterfaceDeclaration) 
														or c.oclIsKindOf(JAVA!EnumDeclaration)
										)
										->collect(c | if c.originalCompilationUnit.oclIsUndefined() 
														then OclUndefined
														else c.originalCompilationUnit.imports
													endif )->flatten()
										->union(
											jPackage.ownedElements	
										),
				nestingPackage <- if (not jPackage.getPackage.oclIsUndefined())then
								 	if (jPackage.getPackage.isAnExternalPackage)then
										jPackage.getPackage
								  	else OclUndefined endif	
								  else OclUndefined endif		
		)		
}

rule createDependency{
	from 
		jImportDec : JAVA!ImportDeclaration
	to 
		umlDependency : UML!Dependency (		
			name <- jImportDec.importedElement.name + '_OF_' + jImportDec.refImmediateComposite().name,
			supplier <- if jImportDec.importedElement.oclIsKindOf(JAVA!VariableDeclarationFragment) then 
							jImportDec.importedElement.originalCompilationUnit.types
						else 
							if jImportDec.importedElement.oclIsKindOf(JAVA!AnnotationTypeDeclaration) then
								jImportDec.importedElement.usagesInImports
									-> collect(usImport | usImport.originalCompilationUnit.types)	
							else 
								if (jImportDec.importedElement.oclIsKindOf(JAVA!EnumConstantDeclaration))then
									jImportDec.importedElement.refImmediateComposite()
								else jImportDec.importedElement endif
							endif
						endif
		)
}

---Block
abstract rule abstractBlock2StructuredActivity{
	from
		block	:	JAVA!Block(
			block.getReturnStateGeneratingSAN		
		)
	to
		t	:	UML!StructuredActivityNode(
			node <- Sequence{init, block.statements -> select(state | not state.isReturnStateGeneratingObjectFlow), final} -> flatten()
		),
		
		init	:	UML!InitialNode(),
		final	:	UML!ActivityFinalNode(),
		fcf : UML!ControlFlow(
			name <- 'fromInitLastStatementToFinalNode',
			inStructuredNode <- t,
			target <- final,
			source <- 	if (not block.getReturnStateGeneratingSAN) then
							init
						else 
							block.statements.last().getSourceTargetOrOwnerSAN
						endif
		)	
}

rule Block2StructuredActivity extends abstractBlock2StructuredActivity{
	from
		block	:	JAVA!Block	((not block.refImmediateComposite().oclIsKindOf(JAVA!AbstractMethodDeclaration)) 
									and block.notInInitializerOrFieldOrEnum 
								 	and block.notInAnnotation
									and not block.hasOnlyReturnInstanceCreateNoParam
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Block - ' + block.refImmediateComposite().oclType().toString(),
			inStructuredNode <- block.refImmediateComposite()
		)	
}

rule Block2StructuredActivityForM extends abstractBlock2StructuredActivity{
	from
		block	:	JAVA!Block	(block.refImmediateComposite().oclIsKindOf(JAVA!AbstractMethodDeclaration) 
									and	block.notInAnnotation			
									and not block.hasOnlyReturnInstanceCreateNoParam
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'structured_'+block.refImmediateComposite(),
			activity <- block.getOwningMethod
		)
}

---(Anonymous)Class
abstract rule abstratASTNodeToClass{
	from
		s : JAVA!ASTNode
	to
		t : UML!Classifier(
			name <- 'classifier',
			ownedOperation <- s.bodyDeclarations 
								-> select(d | d.oclIsTypeOf(JAVA!MethodDeclaration))
								-> collect(d | thisModule.resolveTemp(d, 'operation'))
		)
}

rule AnonymousClass extends abstratASTNodeToClass {
	from
		s	:	JAVA!AnonymousClassDeclaration
	to
		t	:	UML!Class(
			name <- if (not s.refImmediateComposite().oclIsKindOf(JAVA!EnumConstantDeclaration)) then
						s.classInstanceCreation.type.type.name
					else 'EnumConstant_' + s.refImmediateComposite().name endif,
			clientDependency <- if (not s.originalCompilationUnit.oclIsUndefined()) then
									s.originalCompilationUnit.imports
								else OclUndefined endif
		)		
	do{
		thisModule.getTypeDec <- thisModule.getTypeDec -> including(s, t);	
	}	
}

rule Class extends abstratASTNodeToClass {
	from
		s	:	JAVA!ClassDeclaration
	to
		t	:	UML!Class(
			name <- s.name,
			clientDependency <- if (not s.originalCompilationUnit.oclIsUndefined()) then
									s.originalCompilationUnit.imports
								else OclUndefined endif
		)		
	do{
		thisModule.getTypeDec <- thisModule.getTypeDec -> including(s, t);	
	}	
}

rule enumDeclaration extends abstratASTNodeToClass {
	from
		s	:	JAVA!EnumDeclaration
	to
		t	:	UML!Class(
			name <- s.name + '-unsupported',
			clientDependency <- if (not s.originalCompilationUnit.oclIsUndefined()) then
									s.originalCompilationUnit.imports
								else OclUndefined endif
		)
	do{
		thisModule.getTypeDec <- thisModule.getTypeDec -> including(s, t);
	}	
}

rule JInterfaceToUmlInterface extends abstratASTNodeToClass {
	from 
		s : JAVA!InterfaceDeclaration
	to 
		t : UML!Interface (
			name <- s.name,
			clientDependency <- if (not s.originalCompilationUnit.oclIsUndefined()) then
									s.originalCompilationUnit.imports
								else OclUndefined endif
		)
	do{
		thisModule.getTypeDec <- thisModule.getTypeDec -> including(s, t);
	}		
}

---All statements
abstract rule abstractExpressStatement{
	from
		s : JAVA!Statement(
			s.notInInitializerOrFieldOrEnum 
		)
	to
		t	:	UML!StructuredActivityNode(
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
				
		init : UML!InitialNode(
			name <- 'initialNode',
			inStructuredNode <- t
		),	
		initialControlFlow: UML!ControlFlow(
			name <- 'fromInitialNodeToFirstStructuredActivityNode',
			inStructuredNode <- t,
			source <- init,
			target <- s.refImmediateComposite().getStatement.getSourceTargetOrOwnerSAN
		),			
				
		finalControlFlow: UML!ControlFlow(
			name <- 'fromLastStructuredActivityNodeToFinalNode',
			inStructuredNode <- t,
			source <- s.refImmediateComposite().getStatement.getSourceTargetOrOwnerSAN,
			target <- final
		),
		final : UML!ActivityFinalNode(
			name <- 'finalNode',
			inStructuredNode <- t
		)
}

abstract rule abstractSpecificExpressStatement{
	from
		s : JAVA!Statement(
			s.notInInitializerOrFieldOrEnum 
		)
	to
		t	:	UML!StructuredActivityNode(
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		
		initialNode : UML!InitialNode(
			name <- 'initialNode',
			inStructuredNode <- t
		),	
		initialControlFlow: UML!ControlFlow(
			name <- 'fromInitialNodeToFirstStructuredActivityNode',
			inStructuredNode <- t,
			source <- initialNode,
			target <- s.refImmediateComposite().getStatement.getSourceTargetOrOwnerSAN
		),			
		
		finalControlFlow: UML!ControlFlow(
			name <- 'fromLastStructuredActivityNodeToFinalNode',
			inStructuredNode <- t,
			source <- s.refImmediateComposite().getStatement.getSourceTargetOrOwnerSAN,
			target <- final
		),
		final : UML!ActivityFinalNode(
			name <- 'finalNode',
			inStructuredNode <- t
		)
}

rule instanceVariableUseNotSettNullExpressState extends abstractExpressStatement{
	from
		s : JAVA!ExpressionStatement(
			s.isInstanceVarUse
			and not s.isImplicitThisExpression
			and not s.isSettingNull
			and not s.isClearingList
			and not s.isAddingInList
			and not s.isRemovingInList
		)
	to		
		t	:	UML!StructuredActivityNode(
			name <- 'Instance variable use'
		),		
		
		objectflow : UML!ObjectFlow(
			name <- 'objectToInputPin',
			inStructuredNode <-	s.getStatement.getSourceTargetOrOwnerSAN,
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- ip,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif
		),
		ip : UML!InputPin(
			name <- 'objectInput',
			incoming <- objectflow
		),
		
		readStruct : UML!ReadStructuralFeatureAction(
			name <- 'read',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			outgoing <- outControlFlow,
			object <- ip,
			structuralFeature <- if (not s.expression.oclIsUndefined())then
									if (not s.expression.getObject.oclIsUndefined())then
										s.expression.getObject.getFieldDec 
									else OclUndefined endif	
								  else OclUndefined endif,	
			result <- op
		),	
		
		outControlFlow	:	UML!ControlFlow(
			name <- 'fromReadStructuralFeatureActionToReturn',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			source <- readStruct,
			target <- 	if (not s.getOwningMethod.body.isReturnStateGeneratingObjectFlow)then
							s.getOwningMethod.body.statements
							-> select(state | state.oclIsKindOf(JAVA!ReturnStatement)
												and not state.isReturnStateGeneratingObjectFlow
							) 
							-> first()
						else OclUndefined endif
						
		),		
		op : UML!OutputPin(
			name <- 'readStructuralFeatureActionOutput',
			outgoing <- outControlFlow
		)
}

rule instanceVariableUseSettNullExpressState extends abstractExpressStatement{
	from
		s : JAVA!ExpressionStatement(
			s.isInstanceVarUse
			and not s.isImplicitThisExpression
			and s.isSettingNull
		)
	to		
		t	:	UML!StructuredActivityNode(
			name <- 'Instance variable use - set null'
		),		
		
		objectflow : UML!ObjectFlow(
			name <- 'objectToInputPin',
			inStructuredNode <-  s.getStatement.getSourceTargetOrOwnerSAN,
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- ip,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif	
		),
		ip : UML!InputPin(
			name <- 'objectInput',
			incoming <- objectflow
		),
		
		readStruct : UML!ReadStructuralFeatureAction(
			name <- 'read',
			inStructuredNode <-  s.getStatement.getSourceTargetOrOwnerSAN,
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			outgoing <- outControlFlow,
			object <- ip,
			structuralFeature <- if (not s.expression.oclIsUndefined())then
									if (not s.expression.getObject.oclIsUndefined())then
										s.expression.getObject.getFieldDec
									else OclUndefined endif
								  else OclUndefined endif,		
			result <- op
		),		
		outControlFlow	:	UML!ControlFlow(
			name <- 'fromReadStructuralFeatureActionToClearStructuralFeatureActionInitNode',
			inStructuredNode <-  s.getStatement.getSourceTargetOrOwnerSAN,
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			source <- readStruct,
			target <- initialNodeCFA
		),		
		op : UML!OutputPin(
			name <- 'readStructuralFeatureActionOutput',
			outgoing <- outControlFlow
		),		
		
		initialNodeCFA : UML!InitialNode(),	
		initialControlFlow : UML!ControlFlow(
			name <- 'fromInitNodeToClearStructuralFeatureActionInit',
			inStructuredNode <- t,
			source <- initialNodeCFA,
			target <- clearStructuralFeature
		),
		inputCFA : UML!InputPin (
			name <- 'clearStructuralFeatureActionInput',
			incoming <- initialControlFlow
		),	
		clearStructuralFeature : UML!ClearStructuralFeatureAction(
			name <- 'clear',
			inStructuredNode <- t,			
			outgoing <- finalControlFlow,
			incoming <- initialControlFlow,
			object <- inputCFA,
			structuralFeature <- if (s.expression.method.parameters -> notEmpty())then
									let express : JAVA!Expression = 
										s.expression.method.parameters
																		-> at(s.expression.arguments
																				-> indexOf(s.expression.arguments
																							-> select(arg | arg.oclIsKindOf(JAVA!NullLiteral))
																				)+1
																		)
																		.usageInVariableAccess	
																		-> first()
									in									
									if (not express.oclIsUndefined()) then
											express.getFieldDec
									else OclUndefined endif										
								else OclUndefined endif,
			result <- thisModule.createOutputPin(s, 'clearStructuralFeatureActionOutput')		
		),
		finalControlFlow : UML!ControlFlow(
			name <- 'fromClearStructuralFeatureActionToFinalNode',
			inStructuredNode <- t,
			source <- clearStructuralFeature,
			target <- final
		),
		final : UML!ActivityFinalNode()
}

rule implicitThis2IntanceVarUsereadSelf extends abstractExpressStatement{
	from
		s	:	JAVA!ExpressionStatement (
			s.isImplicitThisExpression
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Implicit this'
		),		
		
		read	:	UML!ReadSelfAction (
			name <- 'readSelf',
			result <- thisModule.resolveTemp(s.expression, 'op'),
			inStructuredNode <-  s.getStatement.getSourceTargetOrOwnerSAN,
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		
		objectflow : UML!ObjectFlow(
			name <- 'fromObjectToInputPin',
			inStructuredNode <-  s.getStatement.getSourceTargetOrOwnerSAN,
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- ip,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif	
		),
		ip : UML!InputPin(
			name <- 'readStructuralFeatureActioInput',
			incoming <- objectflow
		),
		readStruct : UML!ReadStructuralFeatureAction(
			name <- 'read',
			inStructuredNode <-  s.getStatement.getSourceTargetOrOwnerSAN,
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			outgoing <- outControlFlow,
			object <- ip,
			structuralFeature <- if (not s.expression.oclIsUndefined())then
									if (not s.expression.getObject.oclIsUndefined())then
										s.expression.getObject.getFieldDec	
									else OclUndefined endif	
								  else OclUndefined endif,		
			result <- op
		),		
		outControlFlow	:	UML!ControlFlow(
			name <- 'fromReadStructuralFeatureActionToReturn',
			inStructuredNode <-  s.getStatement.getSourceTargetOrOwnerSAN,
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			source <- readStruct,
			target <- 	if (not s.getOwningMethod.body.isReturnStateGeneratingObjectFlow)then
							s.getOwningMethod.body.statements
							-> select(state | state.oclIsKindOf(JAVA!ReturnStatement)
												and not state.isReturnStateGeneratingObjectFlow
							)
							-> first()
						else OclUndefined endif
		),		
		op : UML!OutputPin(
			name <- 'readStructuralFeatureActionOutput',
			outgoing <- outControlFlow
		)
}

rule expressionStatement extends abstractSpecificExpressStatement{
	from
		s	:	JAVA!ExpressionStatement (
			s.notInInitializerOrFieldOrEnum 
			and s.notInAnnotation 
			and not s.isImplicitThisExpression
			and not s.isInstanceVarUse
			and not s.isClearingList			
			and not s.isAddingInList
			and not s.isRemovingInList
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Not Implicit this, no method used, and no collection used',
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		fcf : UML!ControlFlow(
			name <- 'fromInitialNodeToInitLastStatement'+'Test_1',
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,
			source <- thisModule.resolveTemp(s.refImmediateComposite().getSourceTargetOrOwnerSAN, 'init'),
			target <- t
		)
}

---Clearing list
rule expressionStatementClearListThisInstanVar extends abstractExpressStatement{
	from
		s	:	JAVA!ExpressionStatement (
			s.notInInitializerOrFieldOrEnum			
			and s.notInAnnotation 
			and s.isClearingList			
			and not s.isImplicitThisExpression
			and s.isInstanceVarUse			
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Clear collection - method used'		
		),
		
		objectflow : UML!ObjectFlow(
			name <- 'objectToInputPin',
			inStructuredNode <-  s.getStatement.getSourceTargetOrOwnerSAN,
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- ip,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif	
		),
		ip : UML!InputPin(
			name <- 'objectInput',
			incoming <- objectflow
		),
		--Getter used
		readStruct : UML!ReadStructuralFeatureAction(
			name <- 'read',
			inStructuredNode <-  s.getStatement.getSourceTargetOrOwnerSAN,
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			outgoing <- outControlFlow,
			object <- ip,
			structuralFeature <- if (not s.expression.oclIsUndefined())then
									if (not s.expression.getObject.oclIsUndefined())then
										s.expression.getObject.getFieldDec
									else OclUndefined endif	
								  else OclUndefined endif,		
			result <- op
		),	
		op : UML!OutputPin(
			name <- 'readStructuralFeatureActionOutput',
			outgoing <- outControlFlow
		),
		outControlFlow	:	UML!ControlFlow(
			name <- 'fromReadStructuralFeatureActionToReturn',
			inStructuredNode <-  s.getStatement.getSourceTargetOrOwnerSAN,
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			source <- readStruct,
			target <- if (not s.getOwningMethod.body.isReturnStateGeneratingObjectFlow)then
							s.getOwningMethod.body.statements
							-> select(state | state.oclIsKindOf(JAVA!ReturnStatement)
												and not state.isReturnStateGeneratingObjectFlow
							)
							-> first()
						else OclUndefined endif
		),		
		
		inputCFA : UML!InputPin (
			name <- 'clearStructuralFeatureActionInputPin',
			incoming <- outControlFlow
		),			
		--Clear coll.
		clearStructuralFeature : UML!ClearStructuralFeatureAction(
			name <- 'clear',
			inStructuredNode <- t,			
			outgoing <- finalControlFlow,
			incoming <- outControlFlow,
			object <- inputCFA,
			structuralFeature <- if (s.expression.method.parameters -> notEmpty())then
									let express : JAVA!Expression = 
										s.expression.method.parameters
											-> at(s.expression.arguments
													-> indexOf(s.expression.arguments
																-> select(arg | arg.oclIsKindOf(JAVA!NullLiteral))
													)+1
											)
											.usageInVariableAccess	
											-> first()
									in									
									if (not express.oclIsUndefined()) then
											s.express.getFieldDec									
									else OclUndefined endif	
								else OclUndefined endif,
			result <- thisModule.createOutputPin(s, 'clearStructuralFeatureActionOutputPin')		
		)
}

rule expressionStatementClearListInstanVar extends abstractExpressStatement{
	from
		s	:	JAVA!ExpressionStatement (
			s.notInInitializerOrFieldOrEnum 
			and s.notInAnnotation 
			and s.isClearingList			
			and s.isImplicitThisExpression
			and s.isInstanceVarUse		
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Clear collection - This, method used'
		),
				
		read	:	UML!ReadSelfAction (			
			result <- thisModule.resolveTemp(s.expression, 'op'),
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		
		objectflow : UML!ObjectFlow(
			name <- 'fromObjectToInputPin',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- ip,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif	
		),
		ip : UML!InputPin(
			name <- 'readStructuralFeatureActioInput',
			incoming <- objectflow
		),
		readStruct : UML!ReadStructuralFeatureAction(
			name <- 'read',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,	
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			outgoing <- outControlFlow,
			object <- ip,
			structuralFeature <- if (not s.expression.oclIsUndefined())then
									if (not s.expression.getObject.oclIsUndefined())then
										s.expression.getObject.getFieldDec
									else OclUndefined endif	
								  else OclUndefined endif,		
			result <- op
		),		
		outControlFlow	:	UML!ControlFlow(
			name <- 'fromReadStructuralFeatureActionToReturn',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,	
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			source <- readStruct,
			target <- if (s.getOwningMethod.body.isReturnStateGeneratingObjectFlow)then
							s.getOwningMethod.body.statements
							-> select(state | state.oclIsKindOf(JAVA!ReturnStatement)
												and not state.isReturnStateGeneratingObjectFlow
							)
							-> first()
						else OclUndefined endif
		),		
		op : UML!OutputPin(
			name <- 'readStructuralFeatureActioOutput'
		),
		
		--Clear coll.
		inputCFA : UML!InputPin (
			name <- 'fromOutControlFlowToClearStructuralFeatureAction',
			incoming <- outControlFlow
		),			
		clearStructuralFeature : UML!ClearStructuralFeatureAction(
			name <- 'clear',
			inStructuredNode <- t,			
			outgoing <- finalControlFlow,
			incoming <- outControlFlow,
			object <- inputCFA,
			structuralFeature <- if (s.expression.method.parameters -> notEmpty())then
									let express : JAVA!Expression = 
										s.expression.method.parameters
											-> at(s.expression.arguments
													-> indexOf(s.expression.arguments
																-> select(arg | arg.oclIsKindOf(JAVA!NullLiteral))
													)+1
											)
											.usageInVariableAccess	
											-> first()
									in									
									if (not express.oclIsUndefined()) then
										s.express.getFieldDec
									else OclUndefined endif	
								else OclUndefined endif,
			result <- thisModule.createOutputPin(s, 'clearStructuralFeatureActionOutput')		
		)
}

rule expressionStatementClearListImpThisInstanVar extends abstractExpressStatement{
	from
		s	:	JAVA!ExpressionStatement (
			s.notInInitializerOrFieldOrEnum 
			and s.notInAnnotation 
			and s.isClearingList			
			and s.isImplicitThisExpression
			and not s.isInstanceVarUse	
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Clear collection - Implicit this, no method used'
		),
				
		--Implicit this
		read	:	UML!ReadSelfAction (			
			result <- thisModule.resolveTemp(s.expression, 'op'),
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		
		objectflow : UML!ObjectFlow(
			name <- 'fromObjectToInputPin',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,	
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- inputCFA,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif	
		),
		inputCFA : UML!InputPin (
			name <- 'objectInput',
			incoming <- objectflow
		),	
		
		--Clear coll.
		clearStructuralFeature : UML!ClearStructuralFeatureAction(
			name <- 'clear',
			inStructuredNode <- t,			
			outgoing <- finalControlFlow,
			incoming <- initialControlFlow,
			object <- inputCFA,
			structuralFeature <- if (s.expression.method.parameters -> notEmpty())then
									let express : JAVA!Expression = 
										s.expression.method.parameters
											-> at(s.expression.arguments
													-> indexOf(s.expression.arguments
																-> select(arg | arg.oclIsKindOf(JAVA!NullLiteral))
													)+1
											)
											.usageInVariableAccess	
											-> first()
									in									
									if (not express.oclIsUndefined()) then
										s.express.getFieldDec	
									else OclUndefined endif	
								else OclUndefined endif,
			result <- op			
		),		
		op	:	UML!OutputPin (
			name <- 'clearStructuralFeatureActionOutput'	
		),
		fcf : UML!ControlFlow(
			name <- 'fromInitialNodeToInitLastStatement'+'Test_2',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,
			source <- thisModule.resolveTemp(s.getStatement.getSourceTargetOrOwnerSAN, 'init'),
			target <- s.getSourceTargetOrOwnerSAN
		)	
}

rule expressionStatementClearList extends abstractSpecificExpressStatement{
	from
		s	:	JAVA!ExpressionStatement (
			s.notInInitializerOrFieldOrEnum 
			and s.notInAnnotation 
			and s.isClearingList			
			and not s.isImplicitThisExpression
			and not s.isInstanceVarUse			
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Clear collection - No method used'
		),
		
		fcf : UML!ControlFlow(
			name <- 'fromInitialNodeToInitLastStatement'+'Test_3',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,
			source <- thisModule.resolveTemp(s.getStatement.getSourceTargetOrOwnerSAN, 'init'),
			target <- s.getSourceTargetOrOwnerSAN
		)
}

---Addition of an element in a list
rule expressionStatementAddListThisInstanVar extends abstractExpressStatement{
	from
		s	:	JAVA!ExpressionStatement (
			s.notInInitializerOrFieldOrEnum			
			and s.notInAnnotation 
			and s.isAddingInList			
			and not s.isImplicitThisExpression
			and s.isInstanceVarUse				
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Addition of an element in collection - Method used'		
		),
				
		--Getter used
		objectflow : UML!ObjectFlow(
			name <- 'fromObjectToInputPin',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,	
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- ip,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif	
		),
		ip : UML!InputPin(
			name <- 'readStructuralFeatureActioInput',
			incoming <- objectflow
		),
		readStruct : UML!ReadStructuralFeatureAction(
			name <- 'read',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,	
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			outgoing <- outControlFlow,
			object <- ip,
			structuralFeature <- if (not s.expression.oclIsUndefined())then
									if (not s.expression.getObject.oclIsUndefined())then
										s.expression.getObject.getFieldDec
									else OclUndefined endif
								  else OclUndefined endif,		
			result <- op
		),		
		outControlFlow	:	UML!ControlFlow(
			name <- 'fromReadStructuralFeatureActionToReturn',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,	
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			source <- readStruct,
			target <- if (not s.getOwningMethod.body.isReturnStateGeneratingObjectFlow)then
							s.getOwningMethod.body.statements
							-> select(state | state.oclIsKindOf(JAVA!ReturnStatement)
												and not state.isReturnStateGeneratingObjectFlow
							)
							-> first()
						else OclUndefined endif
		),		
		op : UML!OutputPin(
			name <- 'readStructuralFeatureActioOutput',
			outgoing <- outControlFlow
		),
		
		--Add in coll.
		strucFeatAction : UML!AddStructuralFeatureValueAction(
			name <- 'add',	
			inStructuredNode <- t,
			object <- objectIP,
			value <- valueIP,
			insertAt <- insertAtIP,
			isReplaceAll <- false
		),
		
		objectIP : UML!InputPin(
			name <- 'object',
			incoming <- objectInput
		),
		objectInput : UML!ObjectFlow(
			name <- 'fromObjectToObjectIP',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- objectIP,
			source <- op
		),
		
		valueIP : UML!InputPin(
			name <- 'value',
			incoming <- valueInput
		),
		valueInput : UML!ObjectFlow(
			name <- 'fromValueToValueIP',
			inStructuredNode <-s.getStatement.getSourceTargetOrOwnerSAN,
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- valueIP,
			source <- if (not s.expression.getLastListMethodArgument.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression.getLastListMethodArgument
					  else OclUndefined endif
		),
		
		insertAtIP : UML!InputPin(
			name <- 'insertAt',
			lower <-	if (s.isAnEmptyCollection) then
							0
						else 1 endif,
			upper <- if (s.expression.arguments -> size() = 2 and not s.isAnEmptyCollection) then
						1
					 else -1 endif,
			incoming <- if (s.expression.arguments -> size() = 2 and not s.isAnEmptyCollection) then
							thisModule.createObjectFlowToNode(s, insertAtIP)
						 else thisModule.createObjectFlowToVSA(s, insertAtIP) endif 
		)
}

rule expressionStatementAddListInstanVar extends abstractExpressStatement{
	from
		s	:	JAVA!ExpressionStatement (
			s.notInInitializerOrFieldOrEnum 
			and s.notInAnnotation 
			and s.isAddingInList			
			and s.isImplicitThisExpression
			and s.isInstanceVarUse	
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Addition of an element in collection - This, Method invocation'
		),
				
		read	:	UML!ReadSelfAction (			
			result <- thisModule.resolveTemp(s.expression, 'op'),
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		
		objectflow : UML!ObjectFlow(
			name <- 'fromObjectToInputPin',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,	
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- ip,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif	
		),
		ip : UML!InputPin(
			name <- 'readStructuralFeatureActioInput',
			incoming <- objectflow
		),
		readStruct : UML!ReadStructuralFeatureAction(
			name <- 'read',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,	
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			outgoing <- outControlFlow,
			object <- ip,
			structuralFeature <- if (not s.expression.oclIsUndefined())then
									if (not s.expression.getObject.oclIsUndefined())then
										s.expression.getObject.getFieldDec
									else OclUndefined endif
								  else OclUndefined endif,		
			result <- op
		),		
		outControlFlow	:	UML!ControlFlow(
			name <- 'fromReadStructuralFeatureActionToReturn',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,	
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			source <- readStruct,
			target <- if (not s.getOwningMethod.body.isReturnStateGeneratingObjectFlow)then
							s.getOwningMethod.body.statements
							-> select(state | state.oclIsKindOf(JAVA!ReturnStatement)
												and not state.isReturnStateGeneratingObjectFlow
							)
							-> first()
						else OclUndefined endif
		),		
		op : UML!OutputPin(
			name <- 'readStructuralFeatureActioOutput',
			outgoing <- outControlFlow
		),
		
		--Add in coll.
		strucFeatAction : UML!AddStructuralFeatureValueAction(
			name <- 'add',	
			inStructuredNode <- t,
			object <- objectIP,
			value <- valueIP,
			insertAt <- insertAtIP,
			isReplaceAll <- false
		),
		
		objectIP : UML!InputPin(
			name <- 'object',
			incoming <- objectInput
		),
		objectInput : UML!ObjectFlow(
			name <- 'fromObjectToObjectIP',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,	
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- objectIP,
			source <- op
		),
		
		valueIP : UML!InputPin(
			name <- 'value',
			incoming <- valueInput
		),
		valueInput : UML!ObjectFlow(
			name <- 'fromValueToValueIP',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,	
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- valueIP,
			source <- 	if (not s.expression.getLastListMethodArgument.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression.getLastListMethodArgument
					  else OclUndefined endif
		),
		
		insertAtIP : UML!InputPin(
			name <- 'insertAt',
			lower <-	if (s.isAnEmptyCollection) then
							0
						else 1 endif,
			upper <- if (s.expression.arguments -> size() = 2 and not s.isAnEmptyCollection) then
						1
					 else -1 endif,
			incoming <- if (s.expression.arguments -> size() = 2 and not s.isAnEmptyCollection) then
							thisModule.createObjectFlowToNode(s, insertAtIP)
						 else thisModule.createObjectFlowToVSA(s, insertAtIP) endif 
		)
}

rule expressionStatementAddListImpThisInstanVar extends abstractExpressStatement{
	from
		s	:	JAVA!ExpressionStatement (
			s.notInInitializerOrFieldOrEnum 
			and s.notInAnnotation 
			and s.isAddingInList			
			and s.isImplicitThisExpression
			and not s.isInstanceVarUse	
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Addition of an element in collection - Implicit this, no Method invocation'
		),
				
		--Implicit this
		read	:	UML!ReadSelfAction (			
			result <- thisModule.resolveTemp(s.expression, 'op'),
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		
		--Add in coll.
		strucFeatAction : UML!AddStructuralFeatureValueAction(
			name <- 'add',
			inStructuredNode <- t,
			object <- objectIP,
			value <- valueIP,
			insertAt <- insertAtIP,
			isReplaceAll <- false
		),
		
		objectIP : UML!InputPin(
			name <- 'object',
			incoming <- objectInput
		),
		objectInput : UML!ObjectFlow(
			name <- 'fromObjectToObjectIP',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,	
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- objectIP,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif	
		),
		
		valueIP : UML!InputPin(
			name <- 'value',
			incoming <- valueInput
		),
		valueInput : UML!ObjectFlow(
			name <- 'fromValueToValueIP',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,	
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- valueIP,
			source <- if (not s.expression.getLastListMethodArgument.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression.getLastListMethodArgument
					  else OclUndefined endif
		),
		
		insertAtIP : UML!InputPin(
			name <- 'insertAt',
			lower <-	if (s.isAnEmptyCollection) then
							0
						else 1 endif,
			upper <- if (s.expression.arguments -> size() = 2 and not s.isAnEmptyCollection) then
						1
					 else -1 endif,
			incoming <- if (s.expression.arguments -> size() = 2 and not s.isAnEmptyCollection) then
							thisModule.createObjectFlowToNode(s, insertAtIP)
						 else thisModule.createObjectFlowToVSA(s, insertAtIP) endif 
		)
}

rule expressionStatementAddList extends abstractSpecificExpressStatement{
	from
		s	:	JAVA!ExpressionStatement (
			s.notInInitializerOrFieldOrEnum 
			and s.notInAnnotation 
			and s.isAddingInList			
			and not s.isImplicitThisExpression
			and not s.isInstanceVarUse	
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Addition of an element in collection - no Method invocation'
		),
		
		--Add in coll.
		strucFeatAction : UML!AddStructuralFeatureValueAction(
			name <- 'add',
			inStructuredNode <- t,
			object <- objectIP,
			value <- valueIP,
			insertAt <- insertAtIP,
			isReplaceAll <- false
		),
		
		objectIP : UML!InputPin(
			name <- 'object',
			incoming <- objectInput
		),
		objectInput : UML!ObjectFlow(
			name <- 'fromObjectToObjectIP',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,	
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- objectIP,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						thisModule.resolveTemp(s.expression, 'op')
					  else s.expression endif	
		),
		
		valueIP : UML!InputPin(
			name <- 'value',
			incoming <- valueInput
		),
		valueInput : UML!ObjectFlow(
			name <- 'fromValueToValueIP',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,	
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- valueIP,
			source <- if (not s.expression.getLastListMethodArgument.oclIsKindOf(JAVA!TypeLiteral)) then
							thisModule.resolveTemp(s.expression.getLastListMethodArgument, 'op')
					  else s.expression endif
		),
		
		insertAtIP : UML!InputPin(
			name <- 'insertAt',
			lower <-	if (s.isAnEmptyCollection) then
							0
						else 1 endif,
			upper <- if (s.expression.arguments -> size() = 2 and not s.isAnEmptyCollection) then
						1
					 else -1 endif,
			incoming <- if (s.expression.arguments -> size() = 2 and not s.isAnEmptyCollection) then
							thisModule.createObjectFlowToNode(s, insertAtIP)
						 else thisModule.createObjectFlowToVSA(s, insertAtIP) endif 
		),
		fcf : UML!ControlFlow(
			name <- 'fromInitialNodeToInitLastStatement'+'Test_4',
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,
			source <- thisModule.resolveTemp(s.refImmediateComposite().getSourceTargetOrOwnerSAN, 'init'),
			target <- t
		)
}

---Removing an element in a collection
rule expressionStatementRemoveListThisInstanVar extends abstractExpressStatement{
	from
		s	:	JAVA!ExpressionStatement (
			s.notInInitializerOrFieldOrEnum			
			and s.notInAnnotation 
			and s.isRemovingInList		
			and not s.isImplicitThisExpression
			and s.isInstanceVarUse				
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Removing an element in a collection - Method used'		
		),
				
		--Getter used
		objectflow : UML!ObjectFlow(
			name <- 'fromExpressionToReadStructuralFeatureAction',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,	
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- ip,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif	
		),
		ip : UML!InputPin(
			name <- 'objectInput',
			incoming <- objectflow
		),		
		
		readStruct : UML!ReadStructuralFeatureAction(
			name <- 'read',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,	
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			outgoing <- outControlFlow,
			object <- ip,
			structuralFeature <- if (not s.expression.oclIsUndefined())then
									if (not s.expression.getObject.oclIsUndefined())then
										s.expression.getObject.getFieldDec
									else OclUndefined endif	
								  else OclUndefined endif,	
			result <- op
		),		
		
		outControlFlow	:	UML!ControlFlow(
			name <- 'fromReadStructuralFeatureActionToReturn',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,	
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			source <- readStruct,
			target <- if (not s.getOwningMethod.body.isReturnStateGeneratingObjectFlow)then
							s.getOwningMethod.body.statements
							-> select(state | state.oclIsKindOf(JAVA!ReturnStatement)
												and not state.isReturnStateGeneratingObjectFlow
							) 
							-> first()
						else OclUndefined endif
		),		
		op : UML!OutputPin(
			name <- 'controlOutput',
			outgoing <- outControlFlow
		),
		
		--Removing an element in coll.
		inObjflowExpress : UML!ObjectFlow(
			name <- 'fromReadStructuralFeatureActionOutputToForkNode',
			source <- op,
			target <- forkNode,
			inStructuredNode <- t
		),
		
		forkNode : UML!ForkNode(
			name <- 'ReadStructuralFeatureActionOrRemoveStructuralFeatureValueAction',
			incoming <- inObjflowExpress,			
			outgoing <- Sequence{outObjRemSFVA, outObjReadSF},
			inStructuredNode <- t
		),
		
		outObjRemSFVA : UML!ObjectFlow(
			name <- 'fromForkNodeToRemoveStructuralFeatureValueActionInput',
			source <- forkNode,
			target <- inPinRemSFVAObject,
			inStructuredNode <- t
		),
		inPinRemSFVAObject : UML!InputPin(
			name <- 'objectInputOfRemoveStructuralFeatureValueAction',
			incoming <- outObjRemSFVA
		),
		remSFVA : UML!RemoveStructuralFeatureValueAction(
			name <- 'removeStructuralFeatureValueAction',
			object <- inPinRemSFVAObject,
			value <- inPinRemSFVAValue,
			removeAt <- inPinRemSFVARemoveAt,
			isRemoveDuplicates <- false,
			inStructuredNode <- t
		),
		
		inObjReadSF : UML!ObjectFlow(
			name <- 'fromForkNodeToReadStructuralFeatureActionInput',
			source <- forkNode,
			target <- inPinReadSF,
			inStructuredNode <- t
		),
		inPinReadSF : UML!InputPin(
			name <- 'objectInputOfReadStructuralFeatureAction',
			incoming <- inObjReadSF
		),
		
		readSF : UML!ReadStructuralFeatureAction(
			name <- 'read',
			object <- inPinReadSF,			
			result <- thisModule.createOutputPin(s, 'readStructuralFeatureActionOutput'),
			inStructuredNode <- t
		),
		outObjReadSF : UML!ObjectFlow(
			name <- 'fromReadStructuralFeatureActiontoCallBehavior',
			source <- thisModule.createOutputPin('readStructuralFeatureActionOutput'),
			target <- inPinReadSFCBCollGet,
			inStructuredNode <- t
		),
		inPinReadSFCBCollGet : UML!InputPin(
			name <- 'listInputOfCallBehavior'
		),
		contFlowRSFCBCollGet : UML!ControlFlow(
			name <- 'fromReadStructuralFeatureActionToCallBehavior',
			source <- readSF,
			target <- callBCollGet,
			inStructuredNode <- t
		),
		
		callBCollGet : UML!CallBehaviorAction(
			name <- 'callBehaviorAction',
			argument <- Sequence{inPinReadSFCBCollGet,inPinIndCBCollGet},			
			result <- 	if (s.expression.isIndexLessOne) then
							OclUndefined
						else thisModule.createOutputPin(s, 'resultOutputOfCallBehavior') endif,
			inStructuredNode <- t,
			behavior <- thisModule.createListGetFumlLib(s)
		),
		outObjCallBCollGet : UML!ObjectFlow(
			name <- 'fromCallBehaviorResultToRemoveStructuralFeatureValueActionValue',
			source <- 	if (s.expression.isIndexLessOne) then
							OclUndefined
						else thisModule.createOutputPin(s, 'resultOutputOfCallBehavior') endif,
			target <- inPinRemSFVAValue,
			inStructuredNode <- t	
		),
		inPinRemSFVAValue : UML!InputPin(
			name <- 'valueInputOfRemoveStructuralFeatureValueAction'
		),
		
		inObjflowIndexExpress : UML!ObjectFlow(
			name <- 'fromExpressionToForkNodeIndex',
			source <- if (not s.expression.getRemoveCollectionArgument.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression.getRemoveCollectionArgument
					  else OclUndefined endif,						
			target <- forkNodeIndex,
			inStructuredNode <- t
		),
		forkNodeIndex : UML!ForkNode(
			name <- 'fromIndexToCallBehaviorOrRemoveStructuralFeatureValueAction',
			incoming <- inObjflowIndexExpress,			
			outgoing <- Sequence{outObjIndCBCollGet, outObjIndRemSFVA},
			inStructuredNode <- t
		),
		
		outObjIndCBCollGet : UML!ObjectFlow(
			name <- 'objectfromForkNodeIndexToCallBehavior',
			source <- forkNodeIndex,
			target <- callBCollGet,
			inStructuredNode <- t	
		),
		inPinIndCBCollGet : UML!InputPin(
			name <- 'indexInputOfCallBehavior',
			incoming <- outObjIndCBCollGet,
			lower <- 1
		),
		
		outObjIndRemSFVA : UML!ObjectFlow(
			name <- 'objectfromForkNodeIndexToRemoveStructuralFeatureValueAction',
			source <- forkNodeIndex,
			target <- remSFVA,
			inStructuredNode <- t	
		),
		inPinRemSFVARemoveAt : UML!InputPin(
			name <- 'removeAtInputOfRemoveStructuralFeatureValueAction',
			incoming <- outObjIndRemSFVA,
			lower <- 1
		)
}

rule expressionStatementRemoveListInstanVar extends abstractExpressStatement{
	from
		s	:	JAVA!ExpressionStatement (
			s.notInInitializerOrFieldOrEnum 
			and s.notInAnnotation 
			and s.isRemovingInList			
			and s.isImplicitThisExpression
			and s.isInstanceVarUse	
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Removing an element in a collection - This, Method invocation'
		),
				
		--Implicit this
		read	:	UML!ReadSelfAction (	
			name <- 'readSelf',
			result <- thisModule.resolveTemp(s.expression, 'op'),
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		
		--Getter used
		objectflow : UML!ObjectFlow(
			name <- 'fromExpressionToReadStructuralFeatureAction',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,	
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- ip,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif	
		),
		ip : UML!InputPin(
			name <- 'objectInput',
			incoming <- objectflow
		),		
		
		readStruct : UML!ReadStructuralFeatureAction(
			name <- 'read',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,	
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			outgoing <- outControlFlow,
			object <- ip,
			structuralFeature <- if (not s.expression.oclIsUndefined())then
									if (not s.expression.getObject.oclIsUndefined())then
										s.expression.getObject.getFieldDec
									else OclUndefined endif	
								  else OclUndefined endif,	
			result <- op
		),		
		
		outControlFlow	:	UML!ControlFlow(
			name <- 'fromReadStructuralFeatureActionToReturn',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,	
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			source <- readStruct,
			target <- if (not s.getOwningMethod.body.isReturnStateGeneratingObjectFlow)then
							s.getOwningMethod.body.statements
							-> select(state | state.oclIsKindOf(JAVA!ReturnStatement)
												and not state.isReturnStateGeneratingObjectFlow
							)
							-> first()
						else OclUndefined endif
		),		
		op : UML!OutputPin(
			name <- 'controlOutput',
			outgoing <- outControlFlow
		),
		
		--Removing an element in coll.
		inObjflowExpress : UML!ObjectFlow(
			name <- 'fromReadStructuralFeatureActionOutputToForkNode',
			source <- op,
			target <- forkNode,
			inStructuredNode <- t
		),
		
		forkNode : UML!ForkNode(
			name <- 'ReadStructuralFeatureActionOrRemoveStructuralFeatureValueAction',
			incoming <- inObjflowExpress,			
			outgoing <- Sequence{outObjRemSFVA, outObjReadSF},
			inStructuredNode <- t
		),
		
		outObjRemSFVA : UML!ObjectFlow(
			name <- 'fromForkNodeToRemoveStructuralFeatureValueActionInput',
			source <- forkNode,
			target <- inPinRemSFVAObject,
			inStructuredNode <- t
		),
		inPinRemSFVAObject : UML!InputPin(
			name <- 'objectInputOfRemoveStructuralFeatureValueAction',
			incoming <- outObjRemSFVA
		),
		remSFVA : UML!RemoveStructuralFeatureValueAction(
			name <- 'removeStructuralFeatureValueAction',
			object <- inPinRemSFVAObject,
			value <- inPinRemSFVAValue,
			removeAt <- inPinRemSFVARemoveAt,
			isRemoveDuplicates <- false,
			inStructuredNode <- t
		),
		
		inObjReadSF : UML!ObjectFlow(
			name <- 'fromForkNodeToReadStructuralFeatureActionInput',
			source <- forkNode,
			target <- inPinReadSF,
			inStructuredNode <- t
		),
		inPinReadSF : UML!InputPin(
			name <- 'objectInputOfReadStructuralFeatureAction',
			incoming <- inObjReadSF
		),
		
		readSF : UML!ReadStructuralFeatureAction(
			name <- 'read',
			object <- inPinReadSF,			
			result <- thisModule.createOutputPin(s, 'readStructuralFeatureActionOutput'),
			inStructuredNode <- t
		),
		outObjReadSF : UML!ObjectFlow(
			name <- 'fromReadStructuralFeatureActiontoCallBehavior',
			source <- thisModule.createOutputPin(s, 'readStructuralFeatureActionOutput'),
			target <- inPinReadSFCBCollGet,
			inStructuredNode <- t
		),
		inPinReadSFCBCollGet : UML!InputPin(
			name <- 'listInputOfCallBehavior'
		),
		contFlowRSFCBCollGet : UML!ControlFlow(
			name <- 'fromReadStructuralFeatureActionToCallBehavior',
			source <- readSF,
			target <- callBCollGet,
			inStructuredNode <- t
		),
		
		callBCollGet : UML!CallBehaviorAction(
			name <- 'callBehaviorAction',
			argument <- Sequence{inPinReadSFCBCollGet,inPinIndCBCollGet},
			result <- 	if (s.expression.isIndexLessOne) then
							OclUndefined
						else thisModule.createOutputPin(s, 'resultOutputOfCallBehavior') endif,
			inStructuredNode <- t,
			behavior <- thisModule.createListGetFumlLib(s)
		),
		outObjCallBCollGet : UML!ObjectFlow(
			name <- 'fromCallBehaviorResultToRemoveStructuralFeatureValueActionValue',
			source <- 	if (s.expression.isIndexLessOne) then
							OclUndefined
						else thisModule.createOutputPin(s, 'resultOutputOfCallBehavior') endif,
			target <- inPinRemSFVAValue,
			inStructuredNode <- t	
		),
		inPinRemSFVAValue : UML!InputPin(
			name <- 'valueInputOfRemoveStructuralFeatureValueAction'
		),
		
		inObjflowIndexExpress : UML!ObjectFlow(
			name <- 'fromExpressionToForkNodeIndex',
			source <- if (not s.getRemoveCollectionArgument.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression.getRemoveCollectionArgument
					  else OclUndefined endif,					
			target <- forkNodeIndex,
			inStructuredNode <- t
		),
		forkNodeIndex : UML!ForkNode(
			name <- 'fromIndexToCallBehaviorOrRemoveStructuralFeatureValueAction',
			incoming <- inObjflowIndexExpress,			
			outgoing <- Sequence{outObjIndCBCollGet, outObjIndRemSFVA},
			inStructuredNode <- t
		),
		
		outObjIndCBCollGet : UML!ObjectFlow(
			name <- 'objectfromForkNodeIndexToCallBehavior',
			source <- forkNodeIndex,
			target <- callBCollGet,
			inStructuredNode <- t	
		),
		inPinIndCBCollGet : UML!InputPin(
			name <- 'indexInputOfCallBehavior',
			incoming <- outObjIndCBCollGet,
			lower <- 1
		),
		
		outObjIndRemSFVA : UML!ObjectFlow(
			name <- 'objectfromForkNodeIndexToRemoveStructuralFeatureValueAction',
			source <- forkNodeIndex,
			target <- remSFVA,
			inStructuredNode <- t	
		),
		inPinRemSFVARemoveAt : UML!InputPin(
			name <- 'removeAtInputOfRemoveStructuralFeatureValueAction',
			incoming <- outObjIndRemSFVA,
			lower <- 1
		)
}

rule expressionStatementRemoveListImpThisInstanVar extends abstractExpressStatement{
	from
		s	:	JAVA!ExpressionStatement (
			s.notInInitializerOrFieldOrEnum 
			and s.notInAnnotation 
			and s.isRemovingInList			
			and s.isImplicitThisExpression
			and not s.isInstanceVarUse	
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Removing an element in a collection - Implicit this, no Method invocation'
		),
				
		--Implicit this
		read	:	UML!ReadSelfAction (	
			name <- 'readSelfAction',
			result <- thisModule.resolveTemp(s.expression, 'op'),
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		
		--Removing an element in coll.
		inObjflowExpress : UML!ObjectFlow(
			name <- 'fromReadStructuralFeatureActionOutputToForkNode',
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif,
			target <- forkNode,
			inStructuredNode <- t
		),
		
		forkNode : UML!ForkNode(
			name <- 'ReadStructuralFeatureActionOrRemoveStructuralFeatureValueAction',
			incoming <- inObjflowExpress,			
			outgoing <- Sequence{outObjRemSFVA, outObjReadSF},
			inStructuredNode <- t
		),
		
		outObjRemSFVA : UML!ObjectFlow(
			name <- 'fromForkNodeToRemoveStructuralFeatureValueActionInput',
			source <- forkNode,
			target <- inPinRemSFVAObject,
			inStructuredNode <- t
		),
		inPinRemSFVAObject : UML!InputPin(
			name <- 'objectInputOfRemoveStructuralFeatureValueAction',
			incoming <- outObjRemSFVA
		),
		remSFVA : UML!RemoveStructuralFeatureValueAction(
			name <- 'removeStructuralFeatureValueAction',
			object <- inPinRemSFVAObject,
			value <- inPinRemSFVAValue,
			removeAt <- inPinRemSFVARemoveAt,
			isRemoveDuplicates <- false,
			inStructuredNode <- t
		),
		
		inObjReadSF : UML!ObjectFlow(
			name <- 'fromForkNodeToReadStructuralFeatureActionInput',
			source <- forkNode,
			target <- inPinReadSF,
			inStructuredNode <- t
		),
		inPinReadSF : UML!InputPin(
			name <- 'objectInputOfReadStructuralFeatureAction',
			incoming <- inObjReadSF
		),
		
		readSF : UML!ReadStructuralFeatureAction(
			name <- 'read',
			object <- inPinReadSF,			
			result <- thisModule.createOutputPin(s, 'readStructuralFeatureActionOutput'),
			inStructuredNode <- t
		),
		outObjReadSF : UML!ObjectFlow(
			name <- 'fromReadStructuralFeatureActiontoCallBehavior',
			source <- thisModule.createOutputPin(s, 'readStructuralFeatureActionOutput'),
			target <- inPinReadSFCBCollGet,
			inStructuredNode <- t
		),
		inPinReadSFCBCollGet : UML!InputPin(
			name <- 'listInputOfCallBehavior'
		),
		contFlowRSFCBCollGet : UML!ControlFlow(
			name <- 'fromReadStructuralFeatureActionToCallBehavior',
			source <- readSF,
			target <- callBCollGet,
			inStructuredNode <- t
		),
		
		callBCollGet : UML!CallBehaviorAction(
			name <- 'callBehaviorAction',
			argument <- Sequence{inPinReadSFCBCollGet,inPinIndCBCollGet},
			result <- 	if (s.expression.isIndexLessOne) then
							OclUndefined
						else thisModule.createOutputPin(s, 'resultOutputOfCallBehavior') endif,
			inStructuredNode <- t,
			behavior <- thisModule.createListGetFumlLib(s)
		),
		outObjCallBCollGet : UML!ObjectFlow(
			name <- 'fromCallBehaviorResultToRemoveStructuralFeatureValueActionValue',
			source <- 	if (s.expression.isIndexLessOne) then
							OclUndefined
						else thisModule.createOutputPin(s, 'resultOutputOfCallBehavior') endif,
			target <- inPinRemSFVAValue,
			inStructuredNode <- t	
		),
		inPinRemSFVAValue : UML!InputPin(
			name <- 'valueInputOfRemoveStructuralFeatureValueAction'
		),
		
		inObjflowIndexExpress : UML!ObjectFlow(
			name <- 'fromExpressionToForkNodeIndex',
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression.getRemoveCollectionArgument
					  else OclUndefined endif,
			target <- forkNodeIndex,
			inStructuredNode <- t
		),
		forkNodeIndex : UML!ForkNode(
			name <- 'fromIndexToCallBehaviorOrRemoveStructuralFeatureValueAction',
			incoming <- inObjflowIndexExpress,			
			outgoing <- Sequence{outObjIndCBCollGet, outObjIndRemSFVA},
			inStructuredNode <- t
		),
		
		outObjIndCBCollGet : UML!ObjectFlow(
			name <- 'objectfromForkNodeIndexToCallBehavior',
			source <- forkNodeIndex,
			target <- callBCollGet,
			inStructuredNode <- t	
		),
		inPinIndCBCollGet : UML!InputPin(
			name <- 'indexInputOfCallBehavior',
			incoming <- outObjIndCBCollGet,
			lower <- 1
		),
		
		outObjIndRemSFVA : UML!ObjectFlow(
			name <- 'objectfromForkNodeIndexToRemoveStructuralFeatureValueAction',
			source <- forkNodeIndex,
			target <- remSFVA,
			inStructuredNode <- t	
		),
		inPinRemSFVARemoveAt : UML!InputPin(
			name <- 'removeAtInputOfRemoveStructuralFeatureValueAction',
			incoming <- outObjIndRemSFVA,
			lower <- 1
		)
}

rule expressionStatementRemoveList extends abstractExpressStatement{
	from
		s	:	JAVA!ExpressionStatement (
			s.notInInitializerOrFieldOrEnum 
			and s.notInAnnotation 
			and s.isRemovingInList			
			and not s.isImplicitThisExpression
			and not s.isInstanceVarUse	
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Removing an element in a collection - no Method invocation'
		),
		
		--Removing an element in coll.
		inObjflowExpress : UML!ObjectFlow(
			name <- 'fromReadStructuralFeatureActionOutputToForkNode',
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif,
			target <- forkNode,
			inStructuredNode <- t
		),
		
		forkNode : UML!ForkNode(
			name <- 'ReadStructuralFeatureActionOrRemoveStructuralFeatureValueAction',
			incoming <- inObjflowExpress,			
			outgoing <- Sequence{outObjRemSFVA, outObjReadSF},
			inStructuredNode <- t
		),
		
		outObjRemSFVA : UML!ObjectFlow(
			name <- 'fromForkNodeToRemoveStructuralFeatureValueActionInput',
			source <- forkNode,
			target <- inPinRemSFVAObject,
			inStructuredNode <- t
		),
		inPinRemSFVAObject : UML!InputPin(
			name <- 'objectInputOfRemoveStructuralFeatureValueAction',
			incoming <- outObjRemSFVA
		),
		remSFVA : UML!RemoveStructuralFeatureValueAction(
			name <- 'removeStructuralFeatureValueAction',
			object <- inPinRemSFVAObject,
			value <- inPinRemSFVAValue,
			removeAt <- inPinRemSFVARemoveAt,
			isRemoveDuplicates <- false,
			inStructuredNode <- t
		),
		
		inObjReadSF : UML!ObjectFlow(
			name <- 'fromForkNodeToReadStructuralFeatureActionInput',
			source <- forkNode,
			target <- inPinReadSF,
			inStructuredNode <- t
		),
		inPinReadSF : UML!InputPin(
			name <- 'objectInputOfReadStructuralFeatureAction',
			incoming <- inObjReadSF
		),
		
		readSF : UML!ReadStructuralFeatureAction(
			name <- 'read',
			object <- inPinReadSF,			
			result <- op,
			inStructuredNode <- t
		),
		op : UML!OutputPin(
			name <- 'ReadStructuralFeatureActionOutput'
		),
		outObjReadSF : UML!ObjectFlow(
			name <- 'fromReadStructuralFeatureActiontoCallBehavior',
			source <- op,
			target <- inPinReadSFCBCollGet,
			inStructuredNode <- t
		),
		inPinReadSFCBCollGet : UML!InputPin(
			name <- 'listInputOfCallBehavior'
		),
		contFlowRSFCBCollGet : UML!ControlFlow(
			name <- 'fromReadStructuralFeatureActionToCallBehavior',
			source <- readSF,
			target <- callBCollGet,
			inStructuredNode <- t
		),
		
		callBCollGet : UML!CallBehaviorAction(
			name <- 'callBehaviorAction',
			argument <- Sequence{inPinReadSFCBCollGet,inPinIndCBCollGet},
			result <- 	if (s.expression.isIndexLessOne) then
							OclUndefined
						else thisModule.createOutputPin(s,'resultOutputOfCallBehavior') endif,
			inStructuredNode <- t,
			behavior <- thisModule.createListGetFumlLib(s)
		),
		outObjCallBCollGet : UML!ObjectFlow(
			name <- 'fromCallBehaviorResultToRemoveStructuralFeatureValueActionValue',
			source <- 	if (s.expression.isIndexLessOne) then
							OclUndefined
						else thisModule.createOutputPin(s, 'resultOutputOfCallBehavior') endif,
			target <- inPinRemSFVAValue,
			inStructuredNode <- t	
		),
		inPinRemSFVAValue : UML!InputPin(
			name <- 'valueInputOfRemoveStructuralFeatureValueAction'
		),
		
		inObjflowIndexExpress : UML!ObjectFlow(
			name <- 'fromExpressionToForkNodeIndex',
			source <- 	if (not s.expression.getRemoveCollectionArgument.oclIsKindOf(JAVA!TypeLiteral)) then
							s.expression.getRemoveCollectionArgument
					  	else 	
					  		s.expression
						endif,
			target <- forkNodeIndex,
			inStructuredNode <- t
		),
		forkNodeIndex : UML!ForkNode(
			name <- 'fromIndexToCallBehaviorOrRemoveStructuralFeatureValueAction',
			incoming <- inObjflowIndexExpress,			
			outgoing <- Sequence{outObjIndCBCollGet, outObjIndRemSFVA},
			inStructuredNode <- t
		),
		
		outObjIndCBCollGet : UML!ObjectFlow(
			name <- 'objectfromForkNodeIndexToCallBehavior',
			source <- forkNodeIndex,
			target <- callBCollGet,
			inStructuredNode <- t	
		),
		inPinIndCBCollGet : UML!InputPin(
			name <- 'indexInputOfCallBehavior',
			incoming <- outObjIndCBCollGet,
			lower <- 1
		),
		
		outObjIndRemSFVA : UML!ObjectFlow(
			name <- 'objectfromForkNodeIndexToRemoveStructuralFeatureValueAction',
			source <- forkNodeIndex,
			target <- remSFVA,
			inStructuredNode <- t	
		),
		inPinRemSFVARemoveAt : UML!InputPin(
			name <- 'removeAtInputOfRemoveStructuralFeatureValueAction',
			incoming <- outObjIndRemSFVA,
			lower <- 1
		)
}

abstract rule returnStatementGlobal{
	from
		s	:	JAVA!ReturnStatement
	to
		t	:	UML!StructuredActivityNode(
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,	
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			name <- s.getOwningMethod.name +' return'
		),	
		
		ob : UML!ObjectFlow(
			name <- 'fromExpressionToActivityParameterNode',
			activity <- s.getOwningMethod,
			source <- s.getSourceForObjectFlow(),
			target <- apn
		),			
		apn	:	UML!ActivityParameterNode(
			name <- 'return',
			type <- if (s.getOwningMethod.returnType.type.oclIsKindOf(JAVA!ParameterizedType)) then
						s.getOwningMethod.returnType.type.typeArguments ->first().type.excludeUnresolvedTypeDec
					else 
						if (s.getOwningMethod.returnType.type.oclIsKindOf(JAVA!ArrayType)) then
							s.getOwningMethod.returnType.type.elementType.type.excludeUnresolvedTypeDec
						else
							s.getOwningMethod.returnType.type.excludeUnresolvedTypeDec
						endif
					endif,
			parameter <- paramAct
		),
		paramAct	:	UML!Parameter(
			name <- 'return',
			direction <- #return,
			type <- if (s.getOwningMethod.returnType.type.oclIsKindOf(JAVA!ParameterizedType)) then
						s.getOwningMethod.returnType.type.typeArguments ->first().type.excludeUnresolvedTypeDec
					else 
						if (s.getOwningMethod.returnType.type.oclIsKindOf(JAVA!ArrayType)) then
							s.getOwningMethod.returnType.type.elementType.type.excludeUnresolvedTypeDec
						else
							s.getOwningMethod.returnType.type.excludeUnresolvedTypeDec
						endif
					endif,
			lower <- if (s.getOwningMethod.returnType.type.oclIsKindOf(JAVA!ArrayType)) then
						1
					else 0 endif,			
			upper <-	if (s.getOwningMethod.returnType.isAList or s.getOwningMethod.returnType.isASet
								or s.getOwningMethod.returnType.type.oclIsKindOf(JAVA!ArrayType))then
							-1
						else 1	endif
		),
		
		initial : UML!InitialNode(
			name <- 'initialNode',
			inStructuredNode <- t
		),	
		initialControlFlow: UML!ControlFlow(
			name <- 'fromInitialNodeToFirstStructuredActivityNode',
			inStructuredNode <- t,
			source <- initial,
			target <- s.refImmediateComposite().getStatement.getSourceTargetOrOwnerSAN
		),			
		
		finalControlFlow: UML!ControlFlow(
			name <- 'fromLastStructuredActivityNodeToFinalNode',
			inStructuredNode <- t,
			source <- s.refImmediateComposite().getStatement.getSourceTargetOrOwnerSAN,
			target <- final
		),
		final : UML!ActivityFinalNode(
			name <- 'finalNode',
			inStructuredNode <- t
		)
}	

rule returnStatementNoReturnNoArgument extends returnStatementGlobal{
	from
		s	:	JAVA!ReturnStatement (
			not s.isReturnStateGeneratingObjectFlow
			and not s.isImplicitThisExpression
			and not s.isInstanceVarUse
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- s.getOwningMethod.name +' return'
		),
		ob : UML!ObjectFlow(
			name <- 'fromExpressionToActivityParameterNode'
		)
	do{
		thisModule.resolveTemp(s.getOwningMethod, 'act').ownedNode 
			<- 	if (not thisModule.resolveTemp(s.getOwningMethod, 'act').oclIsUndefined()) then
					thisModule.resolveTemp(s.getOwningMethod, 'act').ownedNode -> append(apn)
				else OclUndefined endif;
		thisModule.resolveTemp(s.getOwningMethod, 'act').ownedParameter 
			<-  if (not thisModule.resolveTemp(s.getOwningMethod, 'act').oclIsUndefined()) then
					thisModule.resolveTemp(s.getOwningMethod, 'act').ownedParameter -> append(paramAct)
				else OclUndefined endif;
	}	
}

rule returnStatementConstructCall{
	from
		s	:	JAVA!ReturnStatement (
			s.isReturnStateGeneratingObjectFlow
		)
	to
		ob : UML!ObjectFlow(
			name <- 'fromExpressionToActivityParameterNode',
			activity <- s.getOwningMethod,
			source <- s.getSourceForObjectFlow(),
			target <- apn
		),	
				
		apn	:	UML!ActivityParameterNode(
			name <- 'return',
			type <- if (s.getOwningMethod.returnType.type.oclIsKindOf(JAVA!ParameterizedType)) then
						s.getOwningMethod.returnType.type.typeArguments ->first().type.excludeUnresolvedTypeDec
					else 
						if (s.getOwningMethod.returnType.type.oclIsKindOf(JAVA!ArrayType)) then
							s.getOwningMethod.returnType.type.elementType.type.excludeUnresolvedTypeDec
						else
							s.getOwningMethod.returnType.type.excludeUnresolvedTypeDec
						endif
					endif,
			parameter <- paramAct,
			incoming <- ob
		),
		paramAct	:	UML!Parameter(
			name <- 'return',
			direction <- #return,
			type <- if (s.getOwningMethod.returnType.type.oclIsKindOf(JAVA!ParameterizedType)) then
						s.getOwningMethod.returnType.type.typeArguments ->first().type.excludeUnresolvedTypeDec
					else 
						if (s.getOwningMethod.returnType.type.oclIsKindOf(JAVA!ArrayType)) then
							s.getOwningMethod.returnType.type.elementType.type.excludeUnresolvedTypeDec
						else
							s.getOwningMethod.returnType.type.excludeUnresolvedTypeDec
						endif
					endif,
			lower <- if (s.getOwningMethod.returnType.type.oclIsKindOf(JAVA!ArrayType)) then
						1
					else 0 endif,			
			upper <-	if (s.getOwningMethod.returnType.isAList or s.getOwningMethod.returnType.isASet
								or s.getOwningMethod.returnType.type.oclIsKindOf(JAVA!ArrayType))then
							-1
						else 1	endif
					
		)
	do{
		thisModule.resolveTemp(s.getOwningMethod, 'act').ownedNode 
			<- 	if (not thisModule.resolveTemp(s.getOwningMethod, 'act').oclIsUndefined()) then
					thisModule.resolveTemp(s.getOwningMethod, 'act').ownedNode -> append(apn)
				else OclUndefined endif;
		thisModule.resolveTemp(s.getOwningMethod, 'act').ownedParameter 
			<-  if (not thisModule.resolveTemp(s.getOwningMethod, 'act').oclIsUndefined()) then
					thisModule.resolveTemp(s.getOwningMethod, 'act').ownedParameter -> append(paramAct)
				else OclUndefined endif;
	}	
}	

rule returnStatementNoMethodCallAndInstanceVarImplcitThis extends returnStatementGlobal{
	from
		s	:	JAVA!ReturnStatement (
			not s.expression.oclIsKindOf(JAVA!MethodInvocation)	
			and s.isImplicitThisExpression
			and s.isInstanceVarUse
		)
	to
		t	:	UML!StructuredActivityNode(),	
		ob : UML!ObjectFlow(
			name <- 'fromExpressionToActivityParameterNode'
		),
		obToReadStruct : UML!ObjectFlow(
			name <- 'fromExpressionToReadStructuralFeatureActionInputOOOOOOOOOOOOOOOOOOO',
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,	
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- ip,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.getSourceForObjectFlow()
					  else OclUndefined endif	
		),
		--(Implicit)This
		read	:	UML!ReadSelfAction (	
			name <- 'readSelfAction',
			result <- thisModule.resolveTemp(s.expression, 'op'),
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		
		ip : UML!InputPin(
			name <- 'readInput'
		),
		readStruct : UML!ReadStructuralFeatureAction(
			name <-'read',
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,	
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			outgoing <- outControlFlow,
			object <- ip,
			structuralFeature <- if (not s.expression.oclIsUndefined())then
									if (not s.expression.getObject.oclIsUndefined())then
										s.expression.getObject.getFieldDec
									else OclUndefined endif	
								  else OclUndefined endif,
			result <- op,
			incoming <- obToReadStruct
		),			
		outControlFlow	:	UML!ControlFlow(
			name <- 'fromReadStructuralFeatureActionToReturn',
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			source <- readStruct,
			target <- if (not s.getOwningMethod.body.isReturnStateGeneratingObjectFlow)then
							s.getOwningMethod.body.statements
							-> select(state | state.oclIsKindOf(JAVA!ReturnStatement)
												and not state.isReturnStateGeneratingObjectFlow
							)
							-> first()
						else OclUndefined endif
		),
	    op : UML!OutputPin (
			name <- 'resultOutput'	
		)
	do{
		thisModule.resolveTemp(s.getOwningMethod, 'act').ownedNode 
			<- 	if (not thisModule.resolveTemp(s.getOwningMethod, 'act').oclIsUndefined()) then
					thisModule.resolveTemp(s.getOwningMethod, 'act').ownedNode -> append(apn)
				else OclUndefined endif;
		thisModule.resolveTemp(s.getOwningMethod, 'act').ownedParameter 
			<-  if (not thisModule.resolveTemp(s.getOwningMethod, 'act').oclIsUndefined()) then
					thisModule.resolveTemp(s.getOwningMethod, 'act').ownedParameter -> append(paramAct)
				else OclUndefined endif;
	}	
}

rule returnStatementNoMethodCallAndInstanceVar extends returnStatementGlobal{
	from
		s	:	JAVA!ReturnStatement (
			not s.expression.oclIsKindOf(JAVA!MethodInvocation)	
			and not s.isImplicitThisExpression
			and s.isInstanceVarUse	
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- s.getOwningMethod.name +' return'
		),	
		ob : UML!ObjectFlow(
			name <- 'fromExpressionToActivityParameterNode'
		),
		obToReadStruct : UML!ObjectFlow(
			name <- 'fromExpressionToReadStructuralFeatureActionInput',
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,	
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- ip,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.getSourceForObjectFlow()
					  else OclUndefined endif	
		),

		ip : UML!InputPin(
			name <- 'readInput'
		),
		readStruct : UML!ReadStructuralFeatureAction(
			name <-'read',
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,	
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			outgoing <- outControlFlow,
			object <- ip,
			structuralFeature <- if (not s.expression.oclIsUndefined())then
									if (not s.expression.getObject.oclIsUndefined())then
										s.expression.getObject.getFieldDec
									else OclUndefined endif	
								  else OclUndefined endif,
			result <- op,
			incoming <- obToReadStruct
		),			
		outControlFlow	:	UML!ControlFlow(
			name <- 'fromReadStructuralFeatureActionToReturn',
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,	
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			source <- readStruct,
			target <- if (not s.getOwningMethod.body.isReturnStateGeneratingObjectFlow)then
							s.getOwningMethod.body.statements
							-> select(state | state.oclIsKindOf(JAVA!ReturnStatement)
												and not state.isReturnStateGeneratingObjectFlow
							)
							-> first()
						else OclUndefined endif
		),
	    op : UML!OutputPin (
			name <- 'resultOutput'	
		)
	do{
		thisModule.resolveTemp(s.getOwningMethod, 'act').ownedNode 
			<- 	if (not thisModule.resolveTemp(s.getOwningMethod, 'act').oclIsUndefined()) then
					thisModule.resolveTemp(s.getOwningMethod, 'act').ownedNode -> append(apn)
				else OclUndefined endif;
		thisModule.resolveTemp(s.getOwningMethod, 'act').ownedParameter 
			<-  if (not thisModule.resolveTemp(s.getOwningMethod, 'act').oclIsUndefined()) then
					thisModule.resolveTemp(s.getOwningMethod, 'act').ownedParameter -> append(paramAct)
				else OclUndefined endif;
	}	
}	
		
rule returnStatementNoMethodCallAndImplicit extends returnStatementGlobal{
	from
		s	:	JAVA!ReturnStatement (
			not s.expression.oclIsKindOf(JAVA!MethodInvocation)	
			and s.isReturnSimpleImplicitThis
		)
	to
		t	:	UML!StructuredActivityNode(
				name <- s.getOwningMethod.name +' return'
		),	
		ob : UML!ObjectFlow(
			name <- 'fromExpressionToActivityParameterNode'
		),
		
		--(Implicit)This
		read	:	UML!ReadSelfAction (	
			name <- 'readSelfAction',
			result <- opRead,
			inStructuredNode <- t
		),
		 opRead : UML!OutputPin (
			name <- 'readSelfOutput'	
		),
		
		obToReadStruct : UML!ObjectFlow(
			name <- 'fromExpressionToReadStructuralFeatureActionInput',
			inStructuredNode <- t,
			source <- opRead,
			target <- ip			
		),	
		
		ip : UML!InputPin(
			name <- 'readStructInput',
			incoming <- obToReadStruct
		),
		readStruct : UML!ReadStructuralFeatureAction(
			name <-'read',
			inStructuredNode <- t,
			object <- ip,
			structuralFeature <- if (not s.expression.oclIsUndefined())then
									if (not s.expression.getObject.oclIsUndefined())then
										s.expression.getObject.getFieldDec
									else OclUndefined endif	
								  else OclUndefined endif,
			result <- op			
		),		
	    op : UML!OutputPin (
			name <- 'resultStructOutput'	
		)
		
	do{
		thisModule.resolveTemp(s.getOwningMethod, 'act').ownedNode 
			<- 	if (not thisModule.resolveTemp(s.getOwningMethod, 'act').oclIsUndefined()) then
					thisModule.resolveTemp(s.getOwningMethod, 'act').ownedNode -> append(apn)
				else OclUndefined endif;
		thisModule.resolveTemp(s.getOwningMethod, 'act').ownedParameter 
			<-  if (not thisModule.resolveTemp(s.getOwningMethod, 'act').oclIsUndefined()) then
					thisModule.resolveTemp(s.getOwningMethod, 'act').ownedParameter -> append(paramAct)
				else OclUndefined endif;
	}	
}

rule returnStatementMethodInvocation extends returnStatementGlobal{
	from
		s	:	JAVA!ReturnStatement (
			s.expression.oclIsKindOf(JAVA!MethodInvocation)	
		)
	to
		t	:	UML!StructuredActivityNode(
				name <- s.getOwningMethod.name +' return'
		),
		ob : UML!ObjectFlow(
			name <- 'fromExpressionToActivityParameterNode'
		),
		--Calling method
		ip	:	UML!InputPin (
			name <- 'targetInput'
		),
		of2CallOperAct : UML!ObjectFlow (
			name <- 'fromMethodInvocationOutPut',
			source <- thisModule.resolveTemp(s.expression.expression, 'op'),
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,	
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- ip
		),
		co	:	UML!CallOperationAction(
			name <- 'callOperationAction',
			name <- if (not s.expression.method.oclIsUndefined()) then
						 s.expression.method.name
					else 'Undefined' endif,
			operation <- thisModule.resolveTemp(s.expression.method, 'operation'),
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,	
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			argument <- s.expression.arguments->collect(a | 	if a.isPrimitiveType then
																	thisModule.createArgument(a)
																else
																	thisModule.createArgumentNotPrimitiv(a)
																endif	
			),
			result <- op,
			incoming <- of2CallOperAct,
			target <- ip
		),
	    op : UML!OutputPin (
			name <- 'resultOutput'	
		)
	do{
		thisModule.resolveTemp(s.getOwningMethod, 'act').ownedNode 
			<- 	if (not thisModule.resolveTemp(s.getOwningMethod, 'act').oclIsUndefined()) then
					thisModule.resolveTemp(s.getOwningMethod, 'act').ownedNode -> append(apn)
				else OclUndefined endif;
		thisModule.resolveTemp(s.getOwningMethod, 'act').ownedParameter 
			<-  if (not thisModule.resolveTemp(s.getOwningMethod, 'act').oclIsUndefined()) then
					thisModule.resolveTemp(s.getOwningMethod, 'act').ownedParameter -> append(paramAct)
				else OclUndefined endif;
	}	
}

abstract rule abstractConditionnalAndBranchingStatement{
	from
		s : JAVA!Statement(s.oclIsTypeOf(JAVA!AssertStatement)
							or s.oclIsTypeOf(JAVA!SwitchStatement)	
							or s.oclIsTypeOf(JAVA!ContinueStatement)	
							or s.oclIsTypeOf(JAVA!EmptyStatement)	
							or s.oclIsTypeOf(JAVA!SynchronizedStatement)	
							or s.oclIsTypeOf(JAVA!ThrowStatement)	
							or s.oclIsTypeOf(JAVA!BreakStatement)	
							or s.oclIsTypeOf(JAVA!SwitchCase)	
		)
	to
		t	:	UML!StructuredActivityNode(
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		pre	:	UML!ControlFlow(
			name <- 'fromPrecedingNodeToCurrent',
			inActivity <- 	s.getContainerActivity,
			inStructuredNode <- s.getContainerStructuredNode.getSourceTargetOrOwnerSAN,	
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			source <- ip,
			target <- t			
		),
		ip : UML!InputPin(
			name <- 'inputPin',
			inStructuredNode <- s.getContainerStructuredNode.getSourceTargetOrOwnerSAN,	
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			outgoing <- pre
		)
}

rule assertStatement extends abstractConditionnalAndBranchingStatement{
	from
		s	:	JAVA!AssertStatement (s.notInInitializerOrFieldOrEnum and s.notInAnnotation)
	to
		t	:	UML!StructuredActivityNode(		
			name <- 'AssertStatement-Incomplete'
		)
}


rule switchStatement extends abstractConditionnalAndBranchingStatement{
	from
		s	:	JAVA!SwitchStatement (s.notInInitializerOrFieldOrEnum and s.notInAnnotation)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'SwitchStatement-Incomplete'
		)
}

rule continue extends abstractConditionnalAndBranchingStatement{
	from
		s	:	JAVA!ContinueStatement (s.notInInitializerOrFieldOrEnum and	s.notInAnnotation)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'continue'
		)
}

rule empty extends abstractConditionnalAndBranchingStatement{
	from
		s	:	JAVA!EmptyStatement (s.notInInitializerOrFieldOrEnum and s.notInAnnotation)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'empty'
		)
}

rule synchro extends abstractConditionnalAndBranchingStatement{
	from
		s	:	JAVA!SynchronizedStatement (s.notInInitializerOrFieldOrEnum and s.notInAnnotation)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Synchronized-incomplete'
		)
}

rule throw extends abstractConditionnalAndBranchingStatement{
	from
		s	:	JAVA!ThrowStatement (s.notInInitializerOrFieldOrEnum and s.notInAnnotation)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'throw'
		),
		pos	:	UML!ControlFlow(
			name <- 'fromStructuredNodeToFinalNode',  
			inActivity <- 	s.getContainerActivity,
			inStructuredNode <- s.getContainerStructuredNode.getSourceTargetOrOwnerSAN,
			activity <- s.getContainerStructuredNode.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			source <- t,
			target <- thisModule.resolveTemp(s.getOwningMethod.body, 'final')
		),
		
		initialNode : UML!InitialNode(
			name <- 'initialNode',
			inStructuredNode <- t
		),
		initialControlFlow: UML!ControlFlow(
			name <- 'fromPrecedingNodeToInitialNode',
			inStructuredNode <- t,
			source <- s.getPreceding().getSourceTargetOrOwnerSAN,
			target <- initialNode
		),
		
		finalControlFlow: UML!ControlFlow(
			name <- 'fromPrecedingNodeToFinalNode',
			inStructuredNode <- t,
			source <- 	s.getPreceding().getSourceTargetOrOwnerSAN,
			target <- final
		),
		final : UML!ActivityFinalNode(
			name <- 'finalNode',
			inStructuredNode <- t
		)
}

rule break extends abstractConditionnalAndBranchingStatement{
	from
		s	:	JAVA!BreakStatement (s.notInInitializerOrFieldOrEnum and s.notInAnnotation)
	to
		t	:	UML!OpaqueAction(
			name <- 'break'
		)
}

rule switchCase extends abstractConditionnalAndBranchingStatement{
	from
		s	:	JAVA!SwitchCase (s.notInInitializerOrFieldOrEnum and s.notInAnnotation)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'SwitchCase-Incomplete'
		)
}

abstract rule abstractLoopAndTryStatement{
	from
		s : JAVA!Statement(s.oclIsTypeOf(JAVA!TryStatement)
							or s.oclIsTypeOf(JAVA!ForStatement)
							or s.oclIsTypeOf(JAVA!EnhancedForStatement)
							or s.oclIsTypeOf(JAVA!WhileStatement)
							or s.oclIsTypeOf(JAVA!DoStatement)
		)
	to
		t	:	UML!StructuredActivityNode(
			inActivity <- 	s.getContainerActivity,
			inStructuredNode <- s.getContainerStructuredNode.getSourceTargetOrOwnerSAN,
			activity <- s.getContainerStructuredNode.getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		pre	:	UML!ControlFlow(
			name <- 'fromPrecedingNodeToCurrent',
			inActivity <- 	s.getContainerActivity,
			inStructuredNode <- s.getContainerStructuredNode.getSourceTargetOrOwnerSAN,
			activity <- s.getContainerStructuredNode.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			source <- 	s.getPreceding().getSourceTargetOrOwnerSAN,
			target <- t
		)
}

rule forStatement extends abstractLoopAndTryStatement{
	from
		s	:	JAVA!ForStatement (s.notInInitializerOrFieldOrEnum and s.notInAnnotation)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'for'
		),
		
		td	:	UML!ObjectFlow(
			name <- 'fromExpressionToDecisionNode',
			inStructuredNode <- t,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif,
			target <- dec,
			name <- '<<decisionInputFlow>>'
		),
				
		ini	:	UML!InitialNode(
			name <- 'initialNode',
			inStructuredNode <- t
		),
		id1	:	UML!ControlFlow(
			name <- 'fromInitNodeToInitializer',
			inStructuredNode <- t,
			source <- ini,
			target <- s.initializers->first()						
		),
		
		jn	:	UML!JoinNode(
			name <- 'joinNode',
			inStructuredNode <- t
		),
		dec	:	UML!DecisionNode(
			name <- 'decisionNode',
			decisionInputFlow <- td, 
			inStructuredNode <- t			
		),
		id2	:	UML!ControlFlow(
			name <- 'fromInitializerToJoinNode',
			inStructuredNode <- t,
			source <- if (not s.initializers->first().oclIsKindOf(JAVA!TypeLiteral)) then
						s.initializers->first()
					  else OclUndefined endif,
			target <- jn
		),		
		id3	:	UML!ControlFlow(
			name <- 'fromJoinNodeToDecisionNode',
			inStructuredNode <- t,
			source <- jn,
			target <- dec
		),		
		
		fc	:	UML!ControlFlow(
			name <- 'fromDecisionNodeToBody',
			inStructuredNode <- t,
			source <- dec,
			target <- s.body.getSourceTargetOrOwnerSAN,
			guard <- uvt
		),
		ef	:	UML!ControlFlow(
			name <- 'fromDecisionNodeToFinalNode',
			inStructuredNode <- t,
			source <- dec,
			target <- final,
			guard <- uvf
		),
		
		uvt	:	UML!LiteralBoolean(
			name <- 'literalBoolean',
			value <- true
		),
		uvf	:	UML!LiteralBoolean(
			name <- 'literalBoolean',
			value <- false
		),
		final : UML!ActivityFinalNode(
			name <- 'finalNode',
			inStructuredNode <- t
		),
		
		id4	:	UML!ControlFlow(
			name <- 'fromBodyToUpdater',
			inStructuredNode <- t,
			source <- 	s.body.getSourceTargetOrOwnerSAN,			
			target <- s.updaters->first()						
		),
		id5	:	UML!ControlFlow(
			name <- 'fromUpdaterToJoinNode',
			inStructuredNode <- t,
			source <- if (not s.updaters->first().oclIsKindOf(JAVA!TypeLiteral)) then
						s.updaters->first()
					  else OclUndefined endif,
			target <- jn
		)
}

rule enhancedForStatement extends abstractLoopAndTryStatement{
	from
		s	:	JAVA!EnhancedForStatement (s.notInInitializerOrFieldOrEnum and s.notInAnnotation)
	to		
		t	:	UML!StructuredActivityNode(
			name <- 'foreach'
		),
		
		ini	:	UML!InitialNode(
			name <- 'initialNode',
			inStructuredNode <- t
		),
		id1	:	UML!ControlFlow(
			name <- 'fromInitNodeToActivityNode', 
			inStructuredNode <- t,
			source <- ini,
			target <- s.expression.getActivityNode()						
		),
		
		of	:	UML!ObjectFlow(
			name <- 'fromActivityNodeToExpansionRegion',
			inStructuredNode <- t,
			source <- s.expression.getActivityNode(),
			target <- er
		),
		er	:	UML!ExpansionRegion(
			name <- 'expansionRegion',
			inStructuredNode <- t
		),
		
		ier	:	UML!InitialNode(
			name <- 'initialNode',
			inStructuredNode <- er
		),
		fe1	:	UML!ControlFlow(
			name <- 'fromInitNodeToBody',
			inStructuredNode <- er,
			source <- ier,
			target <- s.body.getSourceTargetOrOwnerSAN
		),
		
		fe2	:	UML!ControlFlow(
			name <- 'fromBodyToFinalNode',
			inStructuredNode <- er,
			source <-   s.body.getSourceTargetOrOwnerSAN,
			target <- final
		),
		final	:	UML!ActivityFinalNode(
			name <- 'finalNode',
			inStructuredNode <- er
		),
		
		id2	:	UML!ControlFlow(
			name <- 'fromExpansionRegionToFinalNode',
			inStructuredNode <- t,
			source <- er,
			target <- thisModule.createActivityFinalNode(t)
		)
}

rule whileStatement extends abstractLoopAndTryStatement{
	from
		s	:	JAVA!WhileStatement (s.notInInitializerOrFieldOrEnum and s.notInAnnotation)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'while'
		),
		
		jn	:	UML!JoinNode(
			name <- 'joinNode',
			inStructuredNode <- t
		),
		dec	:	UML!DecisionNode(
			name <- 'decisionNode',
			decisionInputFlow <- td, 
			inStructuredNode <- t			
		),		
		ini	:	UML!InitialNode(
			name <- 'initialNode',
			inStructuredNode <- t
		),
		id1	:	UML!ControlFlow(
			name <- 'fromInitialNodeToJoinNode',
			inStructuredNode <- t,
			source <- ini,
			target <- jn
		),
		id2	:	UML!ControlFlow(
			name <- 'fromJoinNodeToDecisionNode',
			inStructuredNode <- t,
			source <- jn,
			target <- dec
		),
		
		td	:	UML!ObjectFlow(
			name <- 'fromExpressionToDecisionNode',
			inStructuredNode <- t,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif,
			target <- dec,
			name <- '<<decisionInputFlow>>'
		),
		
		fc	:	UML!ControlFlow(
			name <- 'fromDecisionNodeToBody',
			inStructuredNode <- t,
			source <- dec,
			target <- s.body.getSourceTargetOrOwnerSAN,
			guard <- uvt
		),
		
		ef	:	UML!ControlFlow(
			name <- 'fromDecisionNodeToFinalNode',
			inStructuredNode <- t,
			source <- dec,
			target <- final,
			guard <- uvf
		),
		uvt	:	UML!LiteralBoolean(
			name <- 'literalBoolean',
			value <- true
		),
		uvf	:	UML!LiteralBoolean(
			name <- 'literalBoolean',
			value <- false
		),
		final : UML!ActivityFinalNode(
			name <- 'literalBoolean',
			inStructuredNode <- t
		),
		
		id3	:	UML!ControlFlow(
			name <- 'fromBodyToJoinNode',
			inStructuredNode <- t,
			source <-   s.body.getSourceTargetOrOwnerSAN,
			target <- jn
		)
}

rule doWhileStatement extends abstractLoopAndTryStatement{
	from
		s	:	JAVA!DoStatement (s.notInInitializerOrFieldOrEnum and s.notInAnnotation)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'doWhile'
		),
		
		jn	:	UML!JoinNode(
			name <- 'joinNode',
			inStructuredNode <- t
		),
		dec	:	UML!DecisionNode(
			name <- 'decisionNode',
			decisionInputFlow <- td, 
			inStructuredNode <- t			
		),
		ini	:	UML!InitialNode(
			name <- 'initialNode',
			inStructuredNode <- t
		),
		id1	:	UML!ControlFlow(
			name <- 'fromInitialNodeToJoinNode', 
			inStructuredNode <- t,
			source <- ini,
			target <- jn
		),
		id2	:	UML!ControlFlow(
			name <- 'fromJoinNodeToBody',
			inStructuredNode <- t,
			source <- jn,
			target <- s.body.getSourceTargetOrOwnerSAN
		),
		td	:	UML!ObjectFlow(
			name <- 'fromExpressionToDecisionNode',
			inStructuredNode <- t,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif,
			target <- dec,
			name <- '<<decisionInputFlow>>'
		),
		fc	:	UML!ControlFlow(
			name <- 'fromDecisionNodeToJoinNode', 
			inStructuredNode <- t,
			source <- dec,
			target <- jn,
			guard <- uvt
		),
		ef	:	UML!ControlFlow(
			name <- 'fromDecisionNodeToFinalNode', 
			inStructuredNode <- t,
			source <- dec,
			target <- final,
			guard <- uvf
		),
		uvt	:	UML!LiteralBoolean(
			name <- 'literalBoolean',
			value <- true
		),
		uvf	:	UML!LiteralBoolean(
			name <- 'literalBoolean',
			value <- false
		),
		final	:	UML!ActivityFinalNode(
			name <- 'literalBoolean',
			inStructuredNode <- t
		),
		
		id3	:	UML!ControlFlow(
			name <- 'fromBodyToDecisionNode', 
			inStructuredNode <- t,
			source <-   s.body.getSourceTargetOrOwnerSAN,
			target <- dec
		)
}

rule tryStatement extends abstractLoopAndTryStatement{
	from
		s	:	JAVA!TryStatement (s.notInInitializerOrFieldOrEnum and s.notInAnnotation)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'try'
		),
		
		ini	:	UML!InitialNode(
			name <- 'initialNode', 
			inStructuredNode <- t
		),
		ib	:	UML!ControlFlow(
			name <- 'fromInitialNodeToBody', 
			inStructuredNode <- t,
			source <- ini,
			target <- s.body.getSourceTargetOrOwnerSAN
		),
		bf	:	UML!ControlFlow(
			name <- 'fromBodyToFinalNode',
			inStructuredNode <- t,
			source <-   s.body.getSourceTargetOrOwnerSAN,
			target <- final
		),
		final	:	UML!ActivityFinalNode(
			name <- 'finalNode', 
			inStructuredNode <- t
		)
}

rule VariableDeclaration {
	from
		s	:	JAVA!VariableDeclarationStatement (	s.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration) 
													and s.notInInitializerOrFieldOrEnum 
													and s.notInAnnotation
		)
	to
		t :	UML!StructuredActivityNode(
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			name <- 'declare_'+s.fragments->first().name
		),		
		oFToForkNode : UML!ObjectFlow(
			name <- 'declare_'+s.fragments->first().name+'_object_flow_to_fork_node',
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,	
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			source <- thisModule.resolveTemp(s.fragments -> first().initializer,'op'),
			target <- forkNode
		),	
		forkNode : UML!ForkNode(
			name <- 'declare_'+s.fragments->first().name+'_fork_node',
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
				
		ocf	: UML!ControlFlow(
			name <- 'from_declare_'+s.fragments->first().name,
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			source <- t,
			target <- 	if not s.getNext().oclIsUndefined() then
							s.getNext().getSourceTargetOrOwnerSAN
						else forkNode endif
		)		
	do{
		thisModule.resolveTemp(s.getNext(), 'fcf').name
			<- 	if not thisModule.resolveTemp(s.getNext(), 'fcf').oclIsUndefined() then
					'to_declare_'+s.fragments->first().name
				else OclUndefined endif;
		thisModule.resolveTemp(s.getNext(), 'fcf').target
			<- 	if not thisModule.resolveTemp(s.getNext(), 'fcf').oclIsUndefined() then
					t
				else OclUndefined endif;
	}		
}

rule ifStatement {
	from
		s	:	JAVA!IfStatement (s.notInInitializerOrFieldOrEnum)
	to
		t	:	UML!StructuredActivityNode(
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			name <- 'If'
		),
		
		init	:	UML!InitialNode(
			name <- 'InitialNode',
			inStructuredNode <- t
		),
		inToDecNContFl : UML!ControlFlow(
			name <- 'InitialNode to decisionNode',
			inStructuredNode <- t,
			source <- init,
			target <- dec
		),
		td	:	UML!ObjectFlow(
			name <- '<<decisionInputFlow>> - Test expression to DecisionNode',
			inStructuredNode <- t,
			source <- s.expression.getActivityNode(),
			target <- dec			
		),
		dec	:	UML!DecisionNode(
			name <- 'DecisionNode - IfStatement',
			decisionInputFlow <- td, 
			inStructuredNode <- t			
		),		
		
		truThen	: UML!ControlFlow(
			name <- 'Then(true) - DecisionNode to ThenStatement',
			inStructuredNode <- t,
			source <- dec,
			target <- s.thenStatement.getSourceTargetOrOwnerSAN,
			guard <- trueGuard
		),
		trueGuard :	UML!LiteralBoolean(
			name <- 'literalBoolean', 
			value <- true
		),
		
		falElse	: UML!ControlFlow(
			name <- 'Else(false) - DecisionNode to ElseStatement',
			inStructuredNode <- t,
			source <- dec,
			target <- 	if s.elseStatement.oclIsUndefined() then 
							thisModule.createEmptyElse(s)
						else
							s.elseStatement.getSourceTargetOrOwnerSAN
						endif,	
			guard <- falseGuard
		),		
		falseGuard : UML!LiteralBoolean(
			name <- 'literalBoolean', 
			value <- false
		),
		
		merNode	:	UML!MergeNode(
			name <- 'Merge Then and Else statements',
			inStructuredNode <- t
		),
		t2j	:	UML!ControlFlow(
			name <- 'Then statement to MergeNode',
			inStructuredNode <- t,
			source <- 	s.thenStatement.getSourceTargetOrOwnerSAN,
			target <- merNode
		),
		e2j	:	UML!ControlFlow(
			name <- 'Else statement to MergeNode',
			inStructuredNode <- t,
			source <- 	if s.elseStatement.oclIsUndefined() 
						then thisModule.createEmptyElse(s)
						else 
							s.elseStatement.getSourceTargetOrOwnerSAN
						endif,
			target <- merNode
		),
		
		forkNode	:	UML!ForkNode(
			name <- 'External and End ForkNode',
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		mergToEndFnContFlow	:	UML!ControlFlow(
			name <- 'MergeNode to End ForkNode',
			inStructuredNode <- t,
			source <- merNode,
			target <- forkNode
		)		
}



rule labelStatement2StructuredActivity {
	from
		s : JAVA!LabeledStatement (
			(not s.refImmediateComposite().oclIsKindOf(JAVA!AbstractMethodDeclaration)) 
			and s.notInInitializerOrFieldOrEnum 
			and s.notInAnnotation
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- s.refImmediateComposite().oclType().toString(),
			inStructuredNode <- if s.oclIsKindOf(JAVA!UnresolvedLabeledStatement)then
									s.getCorrespondingDec.getStatement
								else
									s.getStatement.getSourceTargetOrOwnerSAN
								endif,
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			node <- Sequence{	init, 
								s.body.getSourceTargetOrOwnerSAN,
								final
					}
					->flatten()						
		),
		init	:	UML!InitialNode(
			name <- 'initialNode'
		),
		final	:	UML!ActivityFinalNode(
			name <- 'finalNode'	
		),		
		fcf : UML!ControlFlow(
			name <- 'fromInitBodyNodeToFinalNode', 
			inStructuredNode <- t,
			target <- final,
			source <- 	if (s.body.oclIsUndefined())
							then init
							else 
								if s.oclIsKindOf(JAVA!UnresolvedLabeledStatement)then
									s.getCorrespondingDec.body
								else 
									s.body.getSourceTargetOrOwnerSAN
								endif
						endif
		)
}

rule catchClause {
	from
		s	:	JAVA!CatchClause (s.notInInitializerOrFieldOrEnum and s.notInAnnotation)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'catch ' + 	if s.exception.type.type.oclIsUndefined() 
									then 'Unknown Exception'
									else s.exception.type.type.name
								endif,
			inStructuredNode <-  s.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		
		init	:	UML!InitialNode(
			name <- 'initialNode',
			inStructuredNode <- t
		),
		ib	:	UML!ControlFlow(
			name <- 'fromInitialNodeToBody',
			inStructuredNode <- t,
			source <- init,
			target <- s.body.getSourceTargetOrOwnerSAN
		),
		
		bf	:	UML!ControlFlow(
			name <- 'fromBodyToFinalNode',
			inStructuredNode <- t,
			source <- s.body.getSourceTargetOrOwnerSAN,
			target <- final
		),
		final	:	UML!ActivityFinalNode(
			name <- 'finalNode',
			inStructuredNode <- t
		),
		
		tc	:	UML!ControlFlow(
			name <- if s.exception.type.type.oclIsUndefined() 
						then 'Unknown Exception'
						else s.exception.type.type.name
					endif,
			inStructuredNode <-s.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			source <- 	s.refImmediateComposite().body.getSourceTargetOrOwnerSAN,
			target <- t,
			guard <- ivs
		),
		ivs	:	UML!InstanceValue(
			name <- if s.exception.type.type.oclIsUndefined() 
						then 'Unknown Exception'
						else s.exception.type.type.name
					endif,
			type <- s.exception.type.type.excludeUnresolvedTypeDec
		)
		
}

abstract rule classInstanceCreation2CreateObject {
	from
		ci	:	JAVA!ClassInstanceCreation (	ci.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration) 
												and ci.notInInitializerOrFieldOrEnum 
												and ci.notInAnnotation
		)
	to 		
		createObjectAction : UML!CreateObjectAction(
			name <- 'Constructor Invocation of '+ ci.originalCompilationUnit.name,
			classifier <- 	if(ci.type.type.oclIsKindOf(JAVA!ParameterizedType))then
								ci.method.abstractTypeDeclaration.excludeUnresolvedMethodDec
							else ci.type.type.excludeUnresolvedTypeDec endif,
			result <- op,	
			inStructuredNode <-	ci.getStatement.getSourceTargetOrOwnerSAN,
			activity <- ci.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),		
		op : UML!OutputPin(
			name <- 'Result of constructor invocation of ' + ci.originalCompilationUnit.name,
			type <- if(ci.type.type.oclIsKindOf(JAVA!ParameterizedType))then
						ci.method.abstractTypeDeclaration.excludeUnresolvedMethodDec
					else ci.type.type.excludeUnresolvedTypeDec endif
		)
}

rule classInstanceCreation2CreateObjectNoArgumentNoBlockContainer extends classInstanceCreation2CreateObject{
	from
		ci	:	JAVA!ClassInstanceCreation (
			ci.arguments -> isEmpty()
			and (ci.refImmediateComposite().oclIsKindOf(JAVA!ExpressionStatement)
					or ci.refImmediateComposite().oclIsKindOf(JAVA!ReturnStatement)
			)		
		)
	to 		
		createObjectAction : UML!CreateObjectAction(),
		op : UML!OutputPin(),
		outObjCreateOA : UML!ObjectFlow(
			name <- 'fromOutputConstrucotrInvocationToForkNode',
			activity <- ci.getOwningMethod,
			source <- op,
			target <- forkNode,
			inStructuredNode <-	ci.getStatement.getSourceTargetOrOwnerSAN,
			activity <- ci.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		forkNode : UML!ForkNode(
			incoming <- outObjCreateOA,
			outgoing <- Sequence{inObjCallOA},
			inStructuredNode <-	ci.getStatement.getSourceTargetOrOwnerSAN,
			activity <- ci.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		inObjCallOA : UML!ObjectFlow(
			name <- 'fromforkNodeToCallOperationAction',
			target <- ip,
			source <- forkNode
		),
		co	:	UML!CallOperationAction(
			name <- ci.method.name,
			operation <- thisModule.resolveTemp(ci.method, 'operation'),
			target <- ip,
			argument <- ip
		),
		ip : UML!InputPin (
			name <- 'target'
		)	
	do{
		thisModule.resolveTemp(ci.getStatement, 'initialControlFlow').name 
			<- 	ci.setControlFlowParam('name', 'initialControlFlow', 'fromInitialNodeToCObjectA');
		thisModule.resolveTemp(ci.getStatement, 'initialControlFlow').target 
			<- ci.setControlFlowParam('target', 'initialControlFlow', createObjectAction.result);
		thisModule.resolveTemp(ci.getStatement, 'finalControlFlow').name 
			<- ci.setControlFlowParam('name', 'finalControlFlow', 'fromCOperationAToFinalNode');
		thisModule.resolveTemp(ci.getStatement, 'finalControlFlow').source 
			<- ci.setControlFlowParam('source', 'finalControlFlow', co.target);
		thisModule.resolveTemp(ci.getOwningMethod, 'act').ownedNode
			<- thisModule.resolveTemp(ci.getOwningMethod, 'act').ownedNode 
				-> union(Sequence{co});
		thisModule.resolveTemp(ci.getOwningMethod, 'act').edge
			<- thisModule.resolveTemp(ci.getOwningMethod, 'act').edge 
				-> union(Sequence{inObjCallOA});
	}
}

rule classInstanceCreation2CreateObjectNoArgumentBlockContainer extends classInstanceCreation2CreateObject{
	from
		ci	:	JAVA!ClassInstanceCreation (
			ci.arguments -> isEmpty()
			and not ci.refImmediateComposite().oclIsKindOf(JAVA!ExpressionStatement)
		)
	to 		
		createObjectAction : UML!CreateObjectAction()--,
--		controlFlow : UML!ControlFlow(
--			name <- 'fromExpressionToCreateObjectAction',
--			inStructuredNode <-	ci.getStatement.getSourceTargetOrOwnerSAN,
--			activity <- ci.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
--			source <- ci.getStatement.getSourceTargetOrOwnerSAN,
--			target <- createObjectAction
--		)
	do{
		thisModule.resolveTemp(ci.getStatement, 'initialControlFlow').name 
			<- 	ci.setControlFlowParam('name', 'initialControlFlow', 'fromInitialNodeToCObjectA');
		thisModule.resolveTemp(ci.getStatement, 'initialControlFlow').target 
			<- ci.setControlFlowParam('target', 'initialControlFlow', createObjectAction);
		thisModule.resolveTemp(ci.getStatement, 'finalControlFlow').name 
			<- ci.setControlFlowParam('name', 'finalControlFlow', 'fromCObjectToFinalNode');
		thisModule.resolveTemp(ci.getStatement, 'finalControlFlow').source 
			<- ci.setControlFlowParam('source', 'finalControlFlow', createObjectAction.result);
	}	
}

rule classInstanceCreation2CreateObjectArgument extends classInstanceCreation2CreateObject{
	from
		ci	:	JAVA!ClassInstanceCreation (	
			ci.arguments -> notEmpty()
		)
	to 		
		createObjectAction : UML!CreateObjectAction(),
		op : UML!OutputPin(),
		co	:	UML!CallOperationAction(
			name <- ci.method.name,
			operation <- thisModule.resolveTemp(ci.method, 'operation'),
			target <- ip
		),
		ip : UML!InputPin (
			name <- 'target'
		),		
		inObjCallOA : UML!ObjectFlow(
			name <- 'fromforkNodeToCallOperationAction',
			target <- ip,
			source <- forkNode
		),
		outObjCreateOA : UML!ObjectFlow(
			name <- 'fromOutputConstructorInvocationToForkNode',
			activity <- ci.getOwningMethod,
			source <- op,
			target <- forkNode,
			inStructuredNode <-	ci.getStatement.getSourceTargetOrOwnerSAN,
			activity <- ci.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		forkNode : UML!ForkNode(
			name <- 'forkNode',
			incoming <- outObjCreateOA,
			outgoing <- Sequence{inObjCallOA},
			inStructuredNode <-	ci.getStatement.getSourceTargetOrOwnerSAN,
			activity <- ci.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		objFlow : UML!ObjectFlow(
			name <- 'fromArgumentToCallOperationAction',
			source <- thisModule.resolveTemp(ci.arguments->first(), 'op'),
			target <- ip
		),
		controlFlow : UML!ControlFlow(
			name <- 'fromIntialNodeToLastStatement',
			inStructuredNode <- ci.getStatement.getStatement.getSourceTargetOrOwnerSAN,
			source <- thisModule.resolveTemp(ci.getStatement.getStatement.getSourceTargetOrOwnerSAN, 'init'),
			target <- ci.getStatement.getSourceTargetOrOwnerSAN
		)
	do{
		thisModule.resolveTemp(ci.getStatement, 'initialControlFlow').name 
			<- 	ci.setControlFlowParam('name', 'initialControlFlow', 'fromInitialNodeToCObjectA');	
		thisModule.resolveTemp(ci.getStatement, 'initialControlFlow').target 
			<- ci.setControlFlowParam('target', 'initialControlFlow', createObjectAction.result);
		thisModule.resolveTemp(ci.getStatement, 'finalControlFlow').name 
			<- ci.setControlFlowParam('name', 'finalControlFlow', 'fromCOperationAToFinalNode');
		thisModule.resolveTemp(ci.getStatement, 'finalControlFlow').source 
			<- ci.setControlFlowParam('source', 'finalControlFlow', co.target);
		thisModule.resolveTemp(ci.getOwningMethod, 'act').ownedNode
			<- thisModule.resolveTemp(ci.getOwningMethod, 'act').ownedNode 
				-> union(Sequence{co});
		thisModule.resolveTemp(ci.getOwningMethod, 'act').edge
			<- thisModule.resolveTemp(ci.getOwningMethod, 'act').edge 
				-> union(Sequence{inObjCallOA,objFlow});
	}
}

abstract rule constructorAndMethod2Activity{
	from
		construcOrMethodDec : JAVA!AbstractMethodDeclaration(
			not construcOrMethodDec.oclIsKindOf(JAVA!UnresolvedMethodDeclaration)	
		)
	to
		act	:	UML!Activity(),
		operation : UML!Operation(
			name <- if (not construcOrMethodDec.oclIsKindOf(JAVA!MethodDeclaration)) then
						'Constructor_'+construcOrMethodDec.getConstructorName
					else 'Method_'+construcOrMethodDec.getMethodName endif,
			method <- act,
			ownedParameter <- construcOrMethodDec.parameters
								-> collect(param |thisModule.Parameters2ActivityParameter(param))
		)
}

rule constructor extends constructorAndMethod2Activity {
	from
		construcOrMethodDec : JAVA!ConstructorDeclaration(construcOrMethodDec.notInAnnotation)
	to
		act	:	UML!Activity(
			name <- construcOrMethodDec.getConstructorName,
			visibility <- construcOrMethodDec.getAbsMethDecVisibility
		)
	do{
		thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedOperation <-
			if (not thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').oclIsUndefined()) then
				thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedOperation -> append(operation)
			else OclUndefined endif;
		thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedBehavior <-
			if (not thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').oclIsUndefined()) then
				if (construcOrMethodDec.refImmediateComposite().oclIsTypeOf(JAVA!ClassDeclaration)) then
					thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedBehavior -> append(act)
				else OclUndefined endif
			else OclUndefined endif;
	}	
}

abstract rule abstractConstructorCall2CreateObject {
	from
		ci	:	JAVA!AbstractMethodDeclaration(
			ci.oclIsTypeOf(JAVA!SuperConstructorInvocation)
			or ci.oclIsTypeOf(JAVA!ConstructorInvocation)
		)
	to 
		t	:	UML!StructuredActivityNode(
			inStructuredNode <-	ci.getStatement.getSourceTargetOrOwnerSAN,
			activity <- ci.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		icf	: UML!ControlFlow(
			name <- 'fromPrecedingNodeToCurrent',
			inStructuredNode <- ci.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- ci.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			source <- ci.getPreceding().getSourceTargetOrOwnerSAN,
			target <- t
		)	
}

rule superConstructorCall2CreateObject {
	from
		ci	:	JAVA!SuperConstructorInvocation (
			ci.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration) 
			and ci.notInInitializerOrFieldOrEnum 
			and ci.notInAnnotation
		)
	to 
		t	:	UML!StructuredActivityNode(
			name <- 'Super constructor invocation of '+ ci.originalCompilationUnit.name	,
			inStructuredNode <- ci.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- ci.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		)
}

rule constructorCall2CreateObject {
	from
		ci	:	JAVA!ConstructorInvocation (
			ci.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration) 
			and ci.notInInitializerOrFieldOrEnum 
			and ci.notInAnnotation
		)
	to 
		t	:	UML!StructuredActivityNode(
			name <- 'Constructor invocation of '+ ci.originalCompilationUnit.name,
			inStructuredNode <- ci.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- ci.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		)
}

rule Methods2Activity extends constructorAndMethod2Activity {
	from
		construcOrMethodDec	:	JAVA!MethodDeclaration	(	
			(not construcOrMethodDec.body.oclIsUndefined()) 
				and
			not construcOrMethodDec.isVoidMethod
				and
		 	not construcOrMethodDec.isBuggedModiscoMethod
				and
		 	construcOrMethodDec.notInAnnotation	
		)
	to
		act	:	UML!Activity(
			name <- construcOrMethodDec.getMethodName,
			visibility <- construcOrMethodDec.getAbsMethDecVisibility,
			redefinedBehavior <- construcOrMethodDec.redefinedMethodDeclaration
		),
		
		init	:	UML!InitialNode(
			name <- 'initialNode',
			activity <- act
		),
		icf : UML!ControlFlow(
			name <- 'fromIntialNodeToBody',
			activity <- act,
			target <- construcOrMethodDec.body.getSourceTargetOrOwnerSAN,
			source <- init 
		),
		
		final	:	UML!ActivityFinalNode(
			name <- 'finalNode',
			activity <- act
		),
		fcf : UML!ControlFlow(
			name <- 'fromBodyToFinalNode',
			activity <- act,
			target <- final,
			source <- construcOrMethodDec.body.getSourceTargetOrOwnerSAN
		)		
	do{
		thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedOperation <-
			if (not thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').oclIsUndefined()) then
				thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedOperation -> append(operation)
			else OclUndefined endif;
		thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedBehavior <-
			if (not thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').oclIsUndefined()) then
				if (construcOrMethodDec.refImmediateComposite().oclIsTypeOf(JAVA!ClassDeclaration)) then
					thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedBehavior -> append(act)
				else OclUndefined endif
			else OclUndefined endif;
	}		
}

rule Methods2ActivityBugModisco extends constructorAndMethod2Activity {
	from
		construcOrMethodDec	:	JAVA!MethodDeclaration	( 
			(not construcOrMethodDec.body.oclIsUndefined()) 
				and
			construcOrMethodDec.isBuggedModiscoMethod
				and
			construcOrMethodDec.notInAnnotation
		)
	to
		act	:	UML!Activity(
			name <-construcOrMethodDec.getMethodName,
			visibility <- construcOrMethodDec.getAbsMethDecVisibility,
			redefinedBehavior <- construcOrMethodDec.redefinedMethodDeclaration
		),
		init	:	UML!InitialNode(
			name <- 'initialNode',
			activity <- act
		),
		icf : UML!ControlFlow(
			name <- 'fromIntialNodeToBody',
			activity <- act,
			target <- construcOrMethodDec.body.getSourceTargetOrOwnerSAN,
			source <- init 
		),
		
		final	:	UML!ActivityFinalNode(
			name <- 'finalNode',
			activity <- act
		),
		fcf : UML!ControlFlow(
			name <- 'fromBodyToFinalNode',
			activity <- act,
			target <- final,
			source <- construcOrMethodDec.body.getSourceTargetOrOwnerSAN
		)		
	do{
		thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedOperation <-
			if (not thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').oclIsUndefined()) then
				thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedOperation -> append(operation)
			else OclUndefined endif;
		thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedBehavior <-
			if (not thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').oclIsUndefined()) then
				if (construcOrMethodDec.refImmediateComposite().oclIsTypeOf(JAVA!ClassDeclaration)) then
					thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedBehavior -> append(act)
				else OclUndefined endif
			else OclUndefined endif;
	}		
}

rule VoidMethod2Activity extends constructorAndMethod2Activity {
	from
		construcOrMethodDec	:	JAVA!MethodDeclaration	(
			(not construcOrMethodDec.body.oclIsUndefined()) 
				and
			construcOrMethodDec.isVoidMethod
				and
			construcOrMethodDec.notInAnnotation	
		)
	to
		act	:	UML!Activity(
			name <- construcOrMethodDec.getMethodName,
			visibility <- construcOrMethodDec.getAbsMethDecVisibility,
			redefinedBehavior <- construcOrMethodDec.redefinedMethodDeclaration
		),
		
		init	:	UML!InitialNode(
			name <- 'initialNode',
			activity <- act
		),
		icf : UML!ControlFlow(
			name <- 'fromIntialNodeToBody',
			activity <- act,
			target <- construcOrMethodDec.body.getSourceTargetOrOwnerSAN,
			source <- init 
		),
		
		final	:	UML!ActivityFinalNode(
			name <- 'finalNode',
			activity <- act
		),
		fcf : UML!ControlFlow(
			name <- 'fromBodyToFinalNode',
			activity <- act,
			target <- final,
			source <- construcOrMethodDec.body.getSourceTargetOrOwnerSAN
		)
	do{
		thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedOperation <-
			if (not thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').oclIsUndefined()) then
				thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedOperation -> append(operation)
			else OclUndefined endif;
		thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedBehavior <-
			if (not thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').oclIsUndefined()) then
				if (construcOrMethodDec.refImmediateComposite().oclIsTypeOf(JAVA!ClassDeclaration)) then
					thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedBehavior -> append(act)
				else OclUndefined endif
			else OclUndefined endif;
	}		
}

rule Methods2ActivityEmptyBody extends constructorAndMethod2Activity {
	from
		construcOrMethodDec	:	JAVA!MethodDeclaration	(	
			(construcOrMethodDec.body.oclIsUndefined()) 
				and
			not construcOrMethodDec.isVoidMethod
				and
		 	not construcOrMethodDec.isBuggedModiscoMethod
				and
		 	construcOrMethodDec.notInAnnotation	
		)
	to
		act	:	UML!Activity(
			name <- construcOrMethodDec.getMethodName,
			visibility <- construcOrMethodDec.getAbsMethDecVisibility,
			redefinedBehavior <- construcOrMethodDec.redefinedMethodDeclaration
		),
		init	:	UML!InitialNode(
			name <- 'initialNode',
			activity <- act
		),
		final	:	UML!ActivityFinalNode(
			name <- 'finalNode',
			activity <- act
		),
		icf : UML!ControlFlow(
			name <- 'fromInitialNodeToFinalNode',
			activity <- act,
			target <- final,
			source <- init 
		)		
	do{
		thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedOperation <-
			if (not thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').oclIsUndefined()) then
				thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedOperation -> append(operation)
			else OclUndefined endif;
		thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedBehavior <-
			if (not thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').oclIsUndefined()) then
				if (construcOrMethodDec.refImmediateComposite().oclIsTypeOf(JAVA!ClassDeclaration)) then
					thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedBehavior -> append(act)
				else OclUndefined endif
			else OclUndefined endif;
	}		
}

rule Methods2ActivityBugModiscoEmptyBody extends constructorAndMethod2Activity {
	from
		construcOrMethodDec	:	JAVA!MethodDeclaration	( 
			(construcOrMethodDec.body.oclIsUndefined()) 
				and
			construcOrMethodDec.isBuggedModiscoMethod
				and
			construcOrMethodDec.notInAnnotation
		)
	to
		act	:	UML!Activity(
			name <-construcOrMethodDec.getMethodName,
			visibility <- construcOrMethodDec.getAbsMethDecVisibility,
			redefinedBehavior <- construcOrMethodDec.redefinedMethodDeclaration
		),
		init	:	UML!InitialNode(
			name <- 'initialNode',
			activity <- act
		),
		final	:	UML!ActivityFinalNode(
			name <- 'finalNode',
			activity <- act
		),
		icf : UML!ControlFlow(
			name <- 'fromInitialNodeToFinalNode',
			activity <- act,
			target <- final,
			source <- init 
		)	
	do{
		thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedOperation <-
			if (not thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').oclIsUndefined()) then
				thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedOperation -> append(operation)
			else OclUndefined endif;
		thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedBehavior <-
			if (not thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').oclIsUndefined()) then
				if (construcOrMethodDec.refImmediateComposite().oclIsTypeOf(JAVA!ClassDeclaration)) then
					thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedBehavior -> append(act)
				else OclUndefined endif
			else OclUndefined endif;
	}		
}

rule VoidMethod2ActivityEmptyBody extends constructorAndMethod2Activity {
	from
		construcOrMethodDec	:	JAVA!MethodDeclaration	(
			(construcOrMethodDec.body.oclIsUndefined()) 
				and
			construcOrMethodDec.isVoidMethod
				and
			construcOrMethodDec.notInAnnotation
		)
	to
		act	:	UML!Activity(
			name <- construcOrMethodDec.getMethodName,
			visibility <- construcOrMethodDec.getAbsMethDecVisibility,
			redefinedBehavior <- construcOrMethodDec.redefinedMethodDeclaration
		),
		init	:	UML!InitialNode(
			name <- 'initialNode',
			activity <- act
		),
		final	:	UML!ActivityFinalNode(
			name <- 'finalNode',
			activity <- act
		),
		icf : UML!ControlFlow(
			name <- 'fromInitialNodeToFinalNode',
			activity <- act,
			target <- final,
			source <- init
		)		
	do{
		thisModule.resolveTemp(construcOrMethodDec.getInstanciedClass, 't').ownedOperation <-
			if (not thisModule.resolveTemp(construcOrMethodDec.getInstanciedClass, 't').oclIsUndefined()) then
				thisModule.resolveTemp(construcOrMethodDec.getInstanciedClass, 't').ownedOperation -> append(operation)
			else OclUndefined endif;
		thisModule.resolveTemp(construcOrMethodDec.getInstanciedClass, 't').ownedBehavior <-
			if (not thisModule.resolveTemp(construcOrMethodDec.getInstanciedClass, 't').oclIsUndefined()) then
				if (construcOrMethodDec.getInstanciedClass.oclIsTypeOf(JAVA!ClassDeclaration)) then
					thisModule.resolveTemp(construcOrMethodDec.getInstanciedClass, 't').ownedBehavior -> append(act)
				else OclUndefined endif
			else OclUndefined endif;
	}		
}

rule methodCallExpressionNullArgument {
	from
		mi	:	JAVA!MethodInvocation (
			not mi.method.oclIsUndefined()
			and mi.notInInitializerOrFieldOrEnum
			and mi.arguments
					-> select(argue | argue.oclIsKindOf(JAVA!NullLiteral))
					-> notEmpty()
		)
	to
		clearStructuralFeature : UML!ClearStructuralFeatureAction(
			name <- 'clear',
			inStructuredNode <- mi.getStatement.getSourceTargetOrOwnerSAN,
			activity <- mi.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,		
			outgoing <- thisModule.resolveTemp(mi.refImmediateComposite(), 'finalControlFlow'),
			incoming <- thisModule.resolveTemp(mi.refImmediateComposite(), 'initialControlFlow'),
			object <- thisModule.resolveTemp(mi.refImmediateComposite(), 'inputCFA'),
			structuralFeature <- if (mi.method.parameters -> notEmpty())then
									let express : JAVA!Expression = 
										mi.method.parameters
													-> at(mi.arguments
															-> indexOf(mi.arguments
																		-> select(arg | arg.oclIsKindOf(JAVA!NullLiteral))
															)+1
													)
													.usageInVariableAccess	
													-> first()
									in									
									if (not express.oclIsUndefined()) then
											express.getFieldDec
									else OclUndefined endif										
								else OclUndefined endif,
			result <- thisModule.createOutputPin(mi.expression, 'clearStructuralFeatureActionOutput')		
		)
	do{
		---Redefinition of element for this case, using the elements from the rule 'expressionStatement' and its extension
		---of 'abstractExpressStatement'
		thisModule.resolveTemp(mi.refImmediateComposite(), 'initialControlFlow').name 
			<- 	if (not thisModule.resolveTemp(mi.refImmediateComposite(), 'initialControlFlow').oclIsUndefined()) then
					'fromInitNodeToClearStructuralFeatureActionInit'
				else OclUndefined endif;
		thisModule.resolveTemp(mi.refImmediateComposite(), 'initialControlFlow').target
			<- 	if (not thisModule.resolveTemp(mi.refImmediateComposite(), 'initialControlFlow').oclIsUndefined()) then
					clearStructuralFeature
				else OclUndefined endif;
		thisModule.resolveTemp(mi.refImmediateComposite(), 'finalControlFlow').name 
			<- 	if (not thisModule.resolveTemp(mi.refImmediateComposite(), 'finalControlFlow').oclIsUndefined()) then
					'fromClearStructuralFeatureActionToFinalNode'
				else OclUndefined endif;
		thisModule.resolveTemp(mi.refImmediateComposite(), 'finalControlFlow').source 
			<- 	if (not thisModule.resolveTemp(mi.refImmediateComposite(), 'finalControlFlow').oclIsUndefined()) then
					clearStructuralFeature
				else OclUndefined endif;
	}
}

abstract rule methodCallExpressionNotNullArgument{
	from
		mi	:	JAVA!MethodInvocation (
			not mi.method.oclIsUndefined()	
			and mi.notInInitializerOrFieldOrEnum			
		)
	to
			co	:	UML!CallOperationAction(
				name <- mi.method.name,
				operation <- thisModule.resolveTemp(mi.method, 'operation'),
				inStructuredNode <- mi.getStatement.getSourceTargetOrOwnerSAN,
				activity <- mi.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
				target <- ip,
				result <- op
			),			
			of1	:	UML!ObjectFlow (
				name <- 'fromExpressionOutputToCallOperationAction',
				inStructuredNode <- mi.getStatement.getSourceTargetOrOwnerSAN,
				activity <- mi.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
				target <- ip,
				source <- thisModule.resolveTemp(mi.getSourceForMethodInvocationFlows, 'op')
			),
			ip	:	UML!InputPin (
				name <- 'objectInput',
				incoming <- of1
			),		
			op	:	UML!OutputPin (
				name <- 'callOperationActionOutput'
			)
}

rule methodCallExpressionNotNullArgumentNotNullExpress extends methodCallExpressionNotNullArgument{
	from
		mi	:	JAVA!MethodInvocation (
			not mi.expression.oclIsUndefined()	
			and if (not mi.method.oclIsUndefined()) then
					not (mi.method.name = 'clear')
				else false endif
			and if mi.arguments -> notEmpty() then
					mi.arguments
						-> select(argue | argue.oclIsKindOf(JAVA!NullLiteral))
						-> isEmpty()
				else false endif	
		)
	to
		co	:	UML!CallOperationAction(
			name <- mi.method.name,
			argument <- inputPinArgue,
			inStructuredNode <- mi.getStatement.getSourceTargetOrOwnerSAN,
			activity <- mi.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),		
		inputPinArgue : UML!InputPin (
			name <- 'target',
			incoming <- if (mi.getOwningMethodInvocation.oclIsUndefined())then
							thisModule.createFlowsForMethodInvocation(co, mi)
						else OclUndefined endif
		)
	do{
		thisModule.resolveTemp(mi.getStatement, 'initialControlFlow').name 
			<- 	mi.setControlFlowParam('name', 'initialControlFlow', 'fromInitialNodeToCOA');
		thisModule.resolveTemp(mi.getStatement, 'initialControlFlow').target 
			<- mi.setControlFlowParam('target', 'initialControlFlow', co.target);
		thisModule.resolveTemp(mi.getStatement, 'finalControlFlow').name 
			<- mi.setControlFlowParam('name', 'finalControlFlow', 'fromCOAToFinalNode');
		thisModule.resolveTemp(mi.getStatement, 'finalControlFlow').source 
			<- mi.setControlFlowParam('source', 'finalControlFlow', co);
	}		
}

rule createFlowsForMethodInvocation(co : UML!CallOperationAction, mi : JAVA!MethodInvocation){
	to
		ofArgue	:	UML!ObjectFlow (
			name <- 'fromArgumentToCallOperationAction',
			inStructuredNode <- mi.getStatement.getSourceTargetOrOwnerSAN,
			activity <- mi.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- co,
			source <- thisModule.resolveTemp(mi.getSourceForMethodInvocationFlows, 'op')
		)
	do{
		ofArgue;
	}
}

rule methodCallExpressionNotNullArgumentNotNullExpressClear extends methodCallExpressionNotNullArgument{
	from
		mi	:	JAVA!MethodInvocation (
			not mi.expression.oclIsUndefined()	
			and if (not mi.method.oclIsUndefined()) then
					mi.method.name = 'clear'
				else false endif
			and if mi.arguments -> notEmpty() then
					mi.arguments
						-> select(argue | argue.oclIsKindOf(JAVA!NullLiteral))
						-> isEmpty()
				else true endif	
		)
	to
		co	:	UML!CallOperationAction(
			name <- mi.method.name,
			argument <- ip,
			inStructuredNode <- mi.getStatement.getSourceTargetOrOwnerSAN,
			activity <- mi.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),			
		ip :	UML!InputPin ()
	do{
		thisModule.resolveTemp(mi.getStatement, 'initialControlFlow').name 
			<- 	mi.setControlFlowParam('name', 'initialControlFlow', 'fromInitialNodeToCOA');
		thisModule.resolveTemp(mi.getStatement, 'initialControlFlow').target 
			<- mi.setControlFlowParam('target', 'initialControlFlow', co.target);
		thisModule.resolveTemp(mi.getStatement, 'finalControlFlow').name 
			<- mi.setControlFlowParam('name', 'finalControlFlow', 'fromCOAToFinalNode');
		thisModule.resolveTemp(mi.getStatement, 'finalControlFlow').source 
			<- mi.setControlFlowParam('source', 'finalControlFlow', co);
	}			
}		

rule methodCallExpressionNotNullArgumentNullExpress extends methodCallExpressionNotNullArgument{
	from
		mi	:	JAVA!MethodInvocation (
			(mi.expression.oclIsUndefined())
			and if (not mi.method.oclIsUndefined()) then
					not (mi.method.name = 'clear')
				else false endif
			and if mi.arguments -> notEmpty() then
					mi.arguments
						-> select(argue | argue.oclIsKindOf(JAVA!NullLiteral))
						-> isEmpty()
				else 
					mi.arguments -> isEmpty() 
				endif
		)
	to		
		co : UML!CallOperationAction(
			name <- 'callOperationAction',
			argument <- mi.arguments
							-> collect(a | 	if a.isPrimitiveType then
												thisModule.createArgument(a)
											else
												thisModule.createArgumentNotPrimitiv(a)
											endif	
							),
			inStructuredNode <- mi.getStatement.getSourceTargetOrOwnerSAN,
			activity <- mi.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			incoming <- of1
		),
		of1	:	UML!ObjectFlow (
			source <- read,
			target <- co
		),
		read	:	UML!ReadSelfAction (
			name <- 'readSelf',
			result <- selfResult,
			inStructuredNode <- mi.getStatement.getSourceTargetOrOwnerSAN,
			activity <- mi.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		selfResult	:	UML!OutputPin (
			name <- 'resultReadSelfActionOutput',
			outgoing <- of1
		)
--		,		
--		inputControlFlow : UML!ControlFlow(
--			name <- 'fromInitialNodeToReadSelfAction',
--			source <- thisModule.resolveTemp(mi.getStatement.getSourceTargetOrOwnerSAN, 'initial'),
--			target <- selfResult,
--			inStructuredNode <-	mi.getStatement.getSourceTargetOrOwnerSAN,
--			activity <- mi.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN
--		),
--		outputControlFlow : UML!ControlFlow(
--			name <- 'fromCallOperationActionToFinalNode',
--			source <- co.result,
--			target <- thisModule.resolveTemp(mi.getStatement.getSourceTargetOrOwnerSAN, 'final'),
--			inStructuredNode <-	mi.getStatement.getSourceTargetOrOwnerSAN,
--			activity <- mi.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN
--		)	
	do{
		thisModule.resolveTemp(mi.getStatement, 'initialControlFlow').name 
			<- 	mi.setControlFlowParam('name', 'initialControlFlow', 'fromInitialNodeToRSA');
		thisModule.resolveTemp(mi.getStatement, 'initialControlFlow').target 
			<- mi.setControlFlowParam('target', 'initialControlFlow', selfResult);
		thisModule.resolveTemp(mi.getStatement, 'finalControlFlow').name 
			<- mi.setControlFlowParam('name', 'finalControlFlow', 'fromCOAToFinalNode');
		thisModule.resolveTemp(mi.getStatement, 'finalControlFlow').source 
			<- mi.setControlFlowParam('source', 'finalControlFlow', co);
	}				
}

rule methodCallExpressionNoArgument extends methodCallExpressionNotNullArgument{
	from
		mi	:	JAVA!MethodInvocation (
			mi.arguments -> isEmpty()
			and if (not mi.method.oclIsUndefined()) then
					not (mi.method.name = 'clear')
				else false endif
		)
	to		
		co : UML!CallOperationAction(
			name <- 'callOperationAction',
			argument <- mi.arguments
							-> collect(a | 	if a.isPrimitiveType then
												thisModule.createArgument(a)
											else
												thisModule.createArgumentNotPrimitiv(a)
											endif	
								),
			inStructuredNode <- mi.getStatement.getSourceTargetOrOwnerSAN,
			activity <- mi.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN											
		),
		of1	:	UML!ObjectFlow ()
--		,
--		inputControlFlow : UML!ControlFlow(
--			name <- 'fromInitialNodeToCallOperationAction',
--			source <- thisModule.resolveTemp(mi.getStatement.getSourceTargetOrOwnerSAN, 'initial'),
--			target <- co.target,
--			inStructuredNode <-	mi.getStatement.getSourceTargetOrOwnerSAN,
--			activity <- mi.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN
--		),
--		outputControlFlow : UML!ControlFlow(
--			name <- 'fromCallOperationActionToFinalNode',
--			source <- co.result,
--			target <- thisModule.resolveTemp(mi.getStatement.getSourceTargetOrOwnerSAN, 'final'),
--			inStructuredNode <-	mi.getStatement.getSourceTargetOrOwnerSAN,
--			activity <- mi.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN
--		)	
	do{
		thisModule.resolveTemp(mi.getStatement, 'initialControlFlow').name 
			<- 	mi.setControlFlowParam('name', 'initialControlFlow', 'fromInitialNodeToCOA');
		thisModule.resolveTemp(mi.getStatement, 'initialControlFlow').target 
			<- mi.setControlFlowParam('target', 'initialControlFlow', co.target);
		thisModule.resolveTemp(mi.getStatement, 'finalControlFlow').name 
			<- mi.setControlFlowParam('name', 'finalControlFlow', 'fromCOAToFinalNode');
		thisModule.resolveTemp(mi.getStatement, 'finalControlFlow').source 
			<- mi.setControlFlowParam('source', 'finalControlFlow', co);
	}			
}

rule superMethodCallExpression {
	from
		mi	:	JAVA!SuperMethodInvocation (mi.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration))
	to
		cba	:	UML!CallBehaviorAction(
			name <- mi.method.name,
			inStructuredNode <- mi.getStatement.getSourceTargetOrOwnerSAN,
			activity <- mi.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			argument <- mi.arguments
							-> collect(a | 	if a.isPrimitiveType then
												thisModule.createArgument(a)
											else
												thisModule.createArgumentNotPrimitiv(a)
											endif	
								),
			result <- op
		),
		op	:	UML!OutputPin (
			name <- 'resultOutput'	
		)
}

abstract rule Parameters2ActivityParameterAndParamNode{
	from
		param	:	JAVA!SingleVariableDeclaration(
			param.notInInitializerOrFieldOrEnum	
			and 
				if param.getOwningMethod.refImmediateComposite().isAPossibleTypeList then
					not param.getOwningMethod.refImmediateComposite().isAList
				else true endif
		)
	to
		apn	:	UML!ActivityParameterNode(
			name <- param.name,
			type <- if (param.type.type.oclIsKindOf(JAVA!ParameterizedType)) then
						param.type.type.typeArguments ->first().type.excludeUnresolvedTypeDec
					else 
						if (param.type.type.oclIsKindOf(JAVA!ArrayType)) then
							param.type.type.elementType.type.excludeUnresolvedTypeDec
						else
							param.type.type.excludeUnresolvedTypeDec 
						endif
					endif,
			parameter <- paramAct		
		),
		
		paramAct	:	UML!Parameter(
			name <- param.name,
			type <- if (param.type.type.oclIsKindOf(JAVA!ParameterizedType)) then
						param.type.type.typeArguments ->first().type.excludeUnresolvedTypeDec
					else 
						if (param.type.type.oclIsKindOf(JAVA!ArrayType)) then
							param.type.type.elementType.type.excludeUnresolvedTypeDec
						else
							param.type.type.excludeUnresolvedTypeDec 
						endif
					endif,
			lower <- if (param.type.type.oclIsKindOf(JAVA!ArrayType)) then
						1
					else 0 endif,			
			upper <-	if (param.type.isAList or param.type.isASet
								or param.type.type.oclIsKindOf(JAVA!ArrayType)
								or param.usageInVariableAccess 
									-> select(param | param.refImmediateComposite().isALoopStatement)
									-> notEmpty())then
							-1
						else 1	endif
		)
}

rule Parameters2ActivityParameterListMethod{
	from
		param	:	JAVA!SingleVariableDeclaration(
			if param.getOwningMethod.refImmediateComposite().isAPossibleTypeList then
				param.getOwningMethod.refImmediateComposite().isAList
			else false endif
		) 
	to	
		apn	:	UML!ActivityParameterNode(
			name <- 'activityParameterNode'	
		)
	do{
		thisModule.resolveTemp(param.getOwningMethod, 'act').ownedNode 
			<- 	if (not thisModule.resolveTemp(param.getOwningMethod, 'act').oclIsUndefined()) then
					thisModule.resolveTemp(param.getOwningMethod, 'act').ownedNode -> append(apn)
				else OclUndefined endif;
	}	
}

rule Parameters2ActivityParameterAndParamNodeNotMethInvoc extends Parameters2ActivityParameterAndParamNode{
	from
		param	:	JAVA!SingleVariableDeclaration(
			let singlVar : JAVA!SingleVariableAccess = 
				param.usageInVariableAccess
						-> first()
			in
				if not singlVar.oclIsUndefined()then
					not singlVar.refImmediateComposite().oclIsKindOf(JAVA!MethodInvocation)
					or (
						if (singlVar.refImmediateComposite().oclIsKindOf(JAVA!MethodInvocation))then
							(
								singlVar.isInMethodInvocationRemove
								or
								(singlVar.refImmediateComposite().arguments
																-> select(argue | argue.oclIsKindOf(JAVA!NullLiteral))
																-> notEmpty()
								)
							)									
							and
							not singlVar.isInMethodInvocationPrimArgument							
						else true endif
					)
				else true endif
		) 
	to	
		apn	:	UML!ActivityParameterNode(),
		paramAct	:	UML!Parameter(),
		ob : UML!ObjectFlow(
			name <- 'fromExpressionToActivityParameterNode',
			activity <- param.getOwningMethod,
			target <-	if thisModule.resolveTemp(param.getExpressionOfSingleVarDec,'ip').oclIsUndefined()
							and thisModule.resolveTemp(param.getExpressionOfSingleVarDec,'clearStructuralFeature').oclIsUndefined()
							and thisModule.resolveTemp(param.getExpressionOfSingleVarDec,'forkNode').oclIsUndefined()
						then
							if param.refImmediateComposite().oclIsKindOf(JAVA!MethodDeclaration)then
								if param.refImmediateComposite().parameters.indexOf(param) = 1 then
									thisModule.resolveTemp(param.getExpressionStatementOfSingleVarDec,'inPinRemSFVAValue')
								else thisModule.resolveTemp(param.getExpressionStatementOfSingleVarDec,'inPinRemSFVAObject')
								endif
							else thisModule.resolveTemp(param.getExpressionOfSingleVarDec,'forkNode') 
							endif
						else 							
							if not thisModule.resolveTemp(param.getExpressionOfSingleVarDec,'clearStructuralFeature').oclIsUndefined() then
								thisModule.resolveTemp(param.getExpressionOfSingleVarDec,'clearStructuralFeature')
							else
								if not thisModule.resolveTemp(param.getExpressionOfSingleVarDec,'forkNode').oclIsUndefined() then
									thisModule.resolveTemp(param.getExpressionOfSingleVarDec,'forkNode')
								else
									thisModule.resolveTemp(param.getExpressionOfSingleVarDec,'ip')
								endif
							endif	
						endif
			,
			source <- apn
		)
	do{
		thisModule.resolveTemp(param.getOwningMethod, 'act').ownedNode 
			<- 	if (not thisModule.resolveTemp(param.getOwningMethod, 'act').oclIsUndefined()) then
					thisModule.resolveTemp(param.getOwningMethod, 'act').ownedNode -> append(apn)
				else OclUndefined endif;
		thisModule.resolveTemp(param.getOwningMethod, 'act').ownedParameter 
			<-  if (not thisModule.resolveTemp(param.getOwningMethod, 'act').oclIsUndefined()) then
					thisModule.resolveTemp(param.getOwningMethod, 'act').ownedParameter -> append(paramAct)
				else OclUndefined endif;
	}	
}

rule PrimTypeParameters2ActivityParameterAndParamNodeMethInvoc extends Parameters2ActivityParameterAndParamNode{
	from
		param	:	JAVA!SingleVariableDeclaration(
			let singlVar : JAVA!SingleVariableAccess = 
				param.usageInVariableAccess
						-> first()
			in
				if not singlVar.oclIsUndefined()then
					if (singlVar.refImmediateComposite().oclIsKindOf(JAVA!MethodInvocation))then
						(
							singlVar.refImmediateComposite().arguments
														-> select(argue | argue.oclIsKindOf(JAVA!NullLiteral))
														-> isEmpty()
							or 
							singlVar.isInMethodInvocationPrimArgument
						) or
						singlVar.refImmediateComposite().arguments -> isEmpty()
					else false endif
				else false endif
		) 
	to	
		apn	:	UML!ActivityParameterNode(),		
		paramAct	:	UML!Parameter()
	do{
		thisModule.resolveTemp(param.getOwningMethod, 'act').ownedNode 
			<- 	if (not thisModule.resolveTemp(param.getOwningMethod, 'act').oclIsUndefined()) then
					thisModule.resolveTemp(param.getOwningMethod, 'act').ownedNode -> append(apn)
				else OclUndefined endif;
		thisModule.resolveTemp(param.getOwningMethod, 'act').ownedParameter 
			<-  if (not thisModule.resolveTemp(param.getOwningMethod, 'act').oclIsUndefined()) then
					thisModule.resolveTemp(param.getOwningMethod, 'act').ownedParameter -> append(paramAct)
				else OclUndefined endif;
	}	
}

rule parameterizedType {
	from
		s	:	JAVA!ParameterizedType
	to
		t	:	UML!Class(
			name <- s.typeArguments -> first().type.name
		)
	do{
		thisModule.getTypeDec <- thisModule.getTypeDec -> including(s, t);	
	}		
}

rule VariableAssignmentNoList {
	from
		as : JAVA!Assignment (	as.isVariableAssignmentNoList
								and as.notInInitializerOrFieldOrEnum 
								and as.notInAnnotation
		)
	to
		t :	UML!StructuredActivityNode(
			inStructuredNode <- as.getStatement.getSourceTargetOrOwnerSAN,
			activity <- as.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			name <- 'declare_'+if (as.leftHandSide.oclIsKindOf(JAVA!UnresolvedItemAccess))then
									as.leftHandSide.element.name
								else as.leftHandSide.field.variable.name endif
		),	
		
		va	:	UML!InputPin(
			name <- 'valueInput',
			incoming <- if (as.rightHandSide.oclIsKindOf(JAVA!SingleVariableAccess))then
							thisModule.resolveTemp(as.rightHandSide.variable, 'ob')
						else OclUndefined endif
		),
		
		objectFlowForObject : UML!ObjectFlow(
			name <- 'fromLeftHandSideStatementToInputObject',
			inStructuredNode <- as.getStatement.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- as.getStatement.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			source <- if (not as.leftHandSide.oclIsKindOf(JAVA!UnresolvedItemAccess))then
						thisModule.resolveTemp(as.leftHandSide.expression, 'op')
					  else OclUndefined endif,
			target <- ip
		),	
		ip	:	UML!InputPin(
			name <- 'objectInput'
		),
		
		initial : UML!InitialNode(
			name <- 'initialNode',
			inStructuredNode <- t
		),
		icf2	: UML!ControlFlow(
			name <- 'fromInitialNodeToStructuredActivityNode',
			inStructuredNode <- t,
			source <- initial,
			target <- t
		),
		
		contFlow : UML!ControlFlow(
			name <- 'fromStructuredActivityNodeToAddStructuralFeatureValueAction',
			inStructuredNode <- t,
			source <- t,
			target <- strucFeatAction
		),
		
		strucFeatAction : UML!AddStructuralFeatureValueAction(
			name <- 'add',
			isReplaceAll <- true,
			object <- ip,
			value <- va,
			structuralFeature <- if (not as.leftHandSide.oclIsKindOf(JAVA!UnresolvedItemAccess))then
									if (not as.leftHandSide.field.oclIsUndefined())then
										as.leftHandSide.field.getFieldDec
									else OclUndefined endif	
								 else OclUndefined endif,
			inStructuredNode <- t
		),		
		
		final : UML!ActivityFinalNode(
			name <- 'finalNode',
			inStructuredNode <- t
		),
		asfvaToFinalNode	: UML!ControlFlow(
			name <- 'fromAddStructuralFeatureValueActionToFinalNode',
			inStructuredNode <- t,
			source <- strucFeatAction,
			target <- final
		)
	do{
		thisModule.resolveTemp(as.getStatement, 'initialControlFlow').name 
			<- if not thisModule.resolveTemp(as.getStatement, 'initialControlFlow').oclIsUndefined()then
					'fromInitialNodeToInternalCurrent'
				else OclUndefined endif;
		thisModule.resolveTemp(as.getStatement, 'initialControlFlow').target 
			<- if not thisModule.resolveTemp(as.getStatement, 'initialControlFlow').oclIsUndefined()then
					thisModule.createStructuredActivityNode(t, 'declare_'+
							if (as.leftHandSide.oclIsKindOf(JAVA!UnresolvedItemAccess))
								then as.leftHandSide.element.name
							else as.leftHandSide.field.variable.name endif
						)
				else OclUndefined endif;
		thisModule.resolveTemp(as.getStatement, 'finalControlFlow').name 
			<- if not thisModule.resolveTemp(as.getStatement, 'finalControlFlow').oclIsUndefined()then
					'fromInternalCurrentToFinalNode'
				else OclUndefined endif;
		thisModule.resolveTemp(as.getStatement, 'finalControlFlow').source 
			<- if not thisModule.resolveTemp(as.getStatement, 'finalControlFlow').oclIsUndefined()then
						thisModule.createStructuredActivityNode(t, 'declare_'+
							if (as.leftHandSide.oclIsKindOf(JAVA!UnresolvedItemAccess))
								then as.leftHandSide.element.name
							else as.leftHandSide.field.variable.name endif
						)
				else OclUndefined endif;	
	}	
}

rule localVariableAssignmentNoList {
	from
		as	:	JAVA!Assignment  (	as.isLocaleVariableAssignmentNoList
									and as.notInInitializerOrFieldOrEnum 
									and as.notInAnnotation
		)
	to
		t :	UML!StructuredActivityNode(
			inStructuredNode <- as.getStatement.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- as.getStatement.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			name <- 'declare_' + as.leftHandSide.variable.name
		),		
		objectFlow : UML!ObjectFlow(
			inStructuredNode <- as.getStatement.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- as.getStatement.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			name <- 'declare_' + as.leftHandSide.variable.name,
			source <- 	as.rightHandSide.getStatement.getSourceTargetOrOwnerSAN,
			target <- forkNode
		),	
		forkNode : UML!ForkNode(
			name <- 'fromRightHandSide',
			inStructuredNode <- as.getStatement.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- as.getStatement.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		icf	: UML!ControlFlow(
			name <- 'fromPrecedingNodeToCurrent',
			inStructuredNode <- as.getStatement.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- as.getStatement.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			source <-	as.getStatement.getPreceding().getSourceTargetOrOwnerSAN,
			target <- t
		)			
}

rule variableAssignementListOrArray {
	from
		iva	:	JAVA!Assignment (	(
										iva.isVariableAssignmentList										
										or
										iva.isAbsDecMethContainedAndArray
									)	
									and iva.notInInitializerOrFieldOrEnum 
									and iva.notInAnnotation
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Variable assignement - List or array',
			inStructuredNode <- iva.refImmediateComposite().refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- iva.refImmediateComposite().refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		
		forkNode : UML!ForkNode(
			name <- 'fromLeftHandSide',
			inStructuredNode <- iva.refImmediateComposite().refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- iva.refImmediateComposite().refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		
		--Object to fork
		objFlowForObjInFork : UML!ObjectFlow(
			name <- 'fromLeftHandSideToFork',
			source <- 	if (not iva.leftHandSide.oclIsTypeOf(JAVA!ArrayAccess) 
							and not iva.leftHandSide.oclIsTypeOf(JAVA!SingleVariableAccess)
						)then
							iva.leftHandSide.expression
						else
							iva.leftHandSide.getStatement.getSourceTargetOrOwnerSAN
						endif,
			target <- forkNode,
			inStructuredNode <- iva.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- iva.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		
		--Fork to ClearStruc.Feature
		objFlowForObjCFS : UML!ObjectFlow(
			name <- 'fromForkToClearStructuralFeatureInput',
			source <- forkNode,
			target <- inputClearStrucFeat,
			inStructuredNode <- iva.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- iva.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),		
		inputClearStrucFeat : UML!InputPin(
			name <- 'objectInputOfClearStructuralFeature'
		),
		
		--Fork to Exp.Region
		objFlowForObjExpReg	: UML!ObjectFlow(
			name <- 'fromForkToExpansionRegionInput',
			source <- forkNode,
			target <- inputExpReg,
			inStructuredNode <- iva.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- iva.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		inputExpReg : UML!InputPin(
			name <- 'objectInputOfExpansionRegion',
			inStructuredNode <- expReg,
			lower <- 1,
			upper <- 1
		),
		
		--ClearStruc.Feature 
		clearStructuralFeature : UML!ClearStructuralFeatureAction(
			name <- 'clear',
			object <- inputClearStrucFeat,
			outgoing <- contFlowCSFExpReg,
			structuralFeature <- 	if (not iva.leftHandSide.oclIsTypeOf(JAVA!ArrayAccess)
										and not iva.leftHandSide.oclIsTypeOf(JAVA!SingleVariableAccess)
									)then
										if (not iva.leftHandSide.field.oclIsUndefined())then
											iva.leftHandSide.field.getFieldDec
										else OclUndefined endif	
									else
										if (iva.leftHandSide.oclIsTypeOf(JAVA!ArrayAccess))then
											if (iva.leftHandSide.array.oclIsTypeOf(JAVA!SingleVariableAccess))then
												iva.leftHandSide.array.getFieldDec
											else OclUndefined endif	
										else 
											if (iva.leftHandSide.oclIsTypeOf(JAVA!SingleVariableAccess))then
												iva.leftHandSide.getFieldDec
											else OclUndefined endif
										endif	
									endif,
			inStructuredNode <- iva.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- iva.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		
		--ClearStruc.Feature to Exp.Region
		contFlowCSFExpReg	:	UML!ControlFlow(
			name <- 'fromClearStructuralFeatureActionToExpansionRegion',
			source <- clearStructuralFeature,
			target <- expReg,
			inStructuredNode <- iva.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- iva.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
				
		--ValueSpecAction to 'insertAt' object flow
		valueSpecAction	:	UML!ValueSpecificationAction(
			name <- 'valueSpecificationAction',
			result <- op,
			value <- literUnlimNatur,
			inStructuredNode <- iva.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- iva.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		literUnlimNatur : UML!LiteralUnlimitedNatural(
			name <- 'literalUnlimitedNatural',
			value <- -1
		),
		op : UML!OutputPin(
			name <- 'outputValueSpecAction'
		),
		
		--Output of ValueSpecAction to input of Exp.Region 'insertAt'
		objFlowForObjInsertAt : UML!ObjectFlow(
			name <- 'fromValueSpecificationActionOutputToExpansionRegionInput',
			source <- op,
			target <- inputExpRegInsertAt,
			inStructuredNode <- iva.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- iva.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),		
		inputExpRegInsertAt : UML!InputPin(	
			name <- 'insertAtInput',
			inStructuredNode <- expReg,
			lower <- 1,
			upper <- 1
		),
		
		--Exp.Region to AddStruct.FeatureValue
		expReg : UML!ExpansionRegion(
			name <- 'expansionRegion',
			incoming <- contFlowCSFExpReg,
			inputElement <- expNode,
			inStructuredNode <- iva.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- iva.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		
		addStructuralFeatureAction : UML!AddStructuralFeatureValueAction(
			name <- 'add',
			isReplaceAll <- false,
			inStructuredNode <- expReg,
			object <- inputObjectAddStrucFeat,
			value <- valueExpression,			
			insertAt <- insertAtValueSpecAction,
			structuralFeature <- 	if (not iva.leftHandSide.oclIsTypeOf(JAVA!ArrayAccess)
										and not iva.leftHandSide.oclIsTypeOf(JAVA!SingleVariableAccess)
									)then
										if (not iva.leftHandSide.field.oclIsUndefined())then
											iva.leftHandSide.field.getFieldDec
										else OclUndefined endif	
									else
										if (iva.leftHandSide.oclIsTypeOf(JAVA!ArrayAccess))then
											if (iva.leftHandSide.array.oclIsTypeOf(JAVA!SingleVariableAccess))then
												iva.leftHandSide.array.getFieldDec
											else OclUndefined endif	
										else	
											if (iva.leftHandSide.oclIsTypeOf(JAVA!SingleVariableAccess))then
												iva.leftHandSide.getFieldDec
											else OclUndefined endif
										endif	
									endif
		),
		
		expNode	:	UML!ExpansionNode(
			name <- 'inputElementOfExpansionRegion',
			inStructuredNode <- expReg
		),
		
		objFlowExpRegToAddStruct : UML!ObjectFlow(
			name <- 'fromInputExpRegToInputAddStruct',
			inStructuredNode <- expReg,
			source <- inputExpReg,
			target <- inputObjectAddStrucFeat			
		),
		inputObjectAddStrucFeat : UML!InputPin(
			name <- 'objectInputAddStructuralFeatureValueAction'
		),		
		
		objFlowValueToAddStruct	: UML!ObjectFlow(
			name <- 'fromInputExpRegValueToInputAddStruct',
			inStructuredNode <- expReg,
			source <- inputClearStrucFeat,
			target <- valueExpression
		),
		valueExpression	: UML!InputPin(
			name <- 'valueInputAddStructuralFeatureValueAction'
		),
		
		objFlowInsertAtToAddStruct : UML!ObjectFlow(
			name <- 'fromInputExpRegInsertAtToInputAddStruct',
			inStructuredNode <- expReg,
			source <- inputExpRegInsertAt,
			target <- insertAtValueSpecAction
		),
		insertAtValueSpecAction	: UML!InputPin(
			name <- 'insertAtInputAddStructuralFeatureValueAction'
		)		
}

rule conditionalExpression { --simplifed mapping in case of empty else branch
	from
		ifs	:	JAVA!ConditionalExpression (ifs.notInInitializerOrFieldOrEnum and ifs.notInAnnotation)
	to
		t	:	UML!StructuredActivityNode(
			inStructuredNode <- ifs.getStatement.getSourceTargetOrOwnerSAN,	
			activity <- ifs.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			name <- 'Conditionnal'
		),
				
		td	:	UML!ObjectFlow(
			name <- 'fromActivityNodeToDecisionNode',
			inStructuredNode <- t,
			source <- ifs.expression.getActivityNode(),
			target <- dec,
			name <- '<<decisionInputFlow>>'
		),
		dec	:	UML!DecisionNode(
			name <- 'decisionNode',
			decisionInputFlow <- td, 
			inStructuredNode <- t			
		),
		
		tru	:	UML!ControlFlow(
			name <- 'fromDecisionNodeToThenStatement',
			inStructuredNode <- t,
			source <- dec,
			target <- ifs.thenExpression.getStatement.getSourceTargetOrOwnerSAN,
			activity <- ifs.thenExpression.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			guard <- uvt
		),
		
		fal	:	UML!ControlFlow(
			name <- 'fromDecisionNodeToElseStatement',
			inStructuredNode <- t,
			source <- dec,
			target <- 	if ifs.elseExpression.oclIsUndefined()
						then thisModule.createEmptyElse(ifs)
						else 
							ifs.elseExpression.getStatement.getSourceTargetOrOwnerSAN								
						endif,
			guard <- uvf
		),
		
		uvt	:	UML!LiteralBoolean(
			name <- 'literalBoolean',
			value <- true
		),
		uvf	:	UML!LiteralBoolean(
			name <- 'literalBoolean',
			value <- false
		),
		
		jn	:	UML!JoinNode(
			name <- 'joinNode',
			inStructuredNode <- t
		),		
		id2	:	UML!ControlFlow(
			name <- 'fromJoinNodeToFinalNode',
			inStructuredNode <- t,
			source <- jn,
			target <- final
		),	
		final	:	UML!ActivityFinalNode(
			name <- 'activityFinalNode',
			inStructuredNode <- t
		)
}

rule expression{
	from
		s	:	JAVA!Expression (					
					(s.refImmediateComposite().oclIsKindOf(JAVA!IfStatement) 
							or s.refImmediateComposite().oclIsKindOf(JAVA!ForStatement) 
							or s.refImmediateComposite().oclIsKindOf(JAVA!DoStatement) 
							or s.refImmediateComposite().oclIsKindOf(JAVA!EnhancedForStatement) 
							or s.refImmediateComposite().oclIsKindOf(JAVA!WhileStatement)
							or not s.refImmediateComposite().isReturnStateGeneratingObjectFlow
					 ) 
					 	and
					 if s.refImmediateComposite().oclIsKindOf(JAVA!ReturnStatement) then
					 	not s.refImmediateComposite().isReturnSimpleImplicitThis
						and not s.refImmediateComposite().expression.isAccessExpression
					 else true endif	
					 	and 
					 s.notInInitializerOrFieldOrEnum 
					 	and 
					s.notInAnnotation 
						and
					s.alreadyManage
		)
	to
		t : UML!StructuredActivityNode(
			name <- 'expression',
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		)
}

rule expressionForVarDeclaration{
	from
		s	:	JAVA!Expression(
					(	s.refImmediateComposite().oclIsKindOf(JAVA!VariableDeclarationFragment) 
								and
						s.refImmediateComposite().refImmediateComposite().oclIsKindOf(JAVA!VariableDeclarationStatement) 
					 ) 
						and
					s.notInInitializerOrFieldOrEnum 
						and 
					s.notInAnnotation 
						and 
					s.alreadyManage
				)					 
	to
		t : UML!StructuredActivityNode(
			name <- 'expression',
			inStructuredNode <- s.refImmediateComposite().refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- s.refImmediateComposite().refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		)
}

abstract rule explicitThis2readSelf {
	from
		this	:	JAVA!ThisExpression (this.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration))
	to
		read	:	UML!ReadSelfAction (
			name <- 'readSelf',
			result <- op,
			inStructuredNode <- this.getStatement.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- this.getStatement.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		op	:	UML!OutputPin (
			name <- 'resultReadSelfActionOutput'	
		)
}

---Concerns the use of field directly using 'this'
---not directly in a return statement
rule explicitThis2readSelfNotInReturn extends explicitThis2readSelf{
	from
		this	:	JAVA!ThisExpression (
			not this.refImmediateComposite().oclIsKindOf(JAVA!ReturnStatement)	
		)
	to		
		read	:	UML!ReadSelfAction (),
		initialControlFlow: UML!ControlFlow(
			name <- 'fromInitialNodeToExpression',
			inStructuredNode <- this.getStatement.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- this.getStatement.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			source <- thisModule.resolveTemp(this.getStatement.refImmediateComposite(), 'init'),
			target <- read
		)
	do{
		thisModule.resolveTemp(this.getStatement.refImmediateComposite(), 'fcf').name
			<- 	if not thisModule.resolveTemp(this.getStatement.refImmediateComposite(), 'fcf').oclIsUndefined() then
					'fromExpressionToFinalNode'
				else OclUndefined endif;
		thisModule.resolveTemp(this.getStatement.refImmediateComposite(), 'fcf').source
			<- 	if not thisModule.resolveTemp(this.getStatement.refImmediateComposite(), 'fcf').oclIsUndefined() then
					read
				else OclUndefined endif;
	}	
}

---Concerns the use of field directly using 'this'
---directly in a return statement
rule explicitThis2readSelfInReturn extends explicitThis2readSelf{
	from
		this	:	JAVA!ThisExpression (
			this.refImmediateComposite().oclIsKindOf(JAVA!ReturnStatement)	
		)
	to		
		read	:	UML!ReadSelfAction (),
		finalControlFlow: UML!ControlFlow(
			name <- 'fromFinalNodeToExpression',
			activity <- this.getStatement.getOwningMethod,
			source <- thisModule.resolveTemp(this.getStatement.refImmediateComposite(), 'final'),
			target <- thisModule.resolveTemp(this.getStatement, 't')
		)
	do{
		thisModule.resolveTemp(this.getStatement.refImmediateComposite(), 'fcf').name
			<- 	if not thisModule.resolveTemp(this.getStatement.refImmediateComposite(), 'fcf').oclIsUndefined() then
					'fromExpressionToFinalNode'
				else OclUndefined endif;
		thisModule.resolveTemp(this.getStatement.refImmediateComposite(), 'fcf').source
			<- 	if not thisModule.resolveTemp(this.getStatement.refImmediateComposite(), 'fcf').oclIsUndefined() then
					thisModule.resolveTemp(this.getStatement, 't')
				else OclUndefined endif;
	}	
}


rule parenthesizedExpression {
	from
		s	:	JAVA!ParenthesizedExpression (s.notInInitializerOrFieldOrEnum and s.notInAnnotation)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Parenthesized',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),	
		
		initialNode : UML!InitialNode(
			name <- 'initialNode',
			inStructuredNode <- t
		),
		initialControlFlow: UML!ControlFlow(
			name <- 'fromInitialNodeToStatement',
			inStructuredNode <- t,
			source <- initialNode,
			target <- 	s.expression.getStatement.getSourceTargetOrOwnerSAN
		),
		
		finalControlFlow: UML!ControlFlow(
			name <- 'fromStatementToFinalNode',
			inStructuredNode <- t,
			source <- 	s.expression.getStatement.getSourceTargetOrOwnerSAN,
			target <- final
		),
		final : UML!ActivityFinalNode(
			name <- 'finalNode',
			inStructuredNode <- t
		)
}

abstract rule operatorexpression {
	from
		ioe	:	JAVA!Expression
	to
		cb	:	UML!CallBehaviorAction(
			behavior <- ioe.getBehavior,
			name <- ioe.operator.toString(),
			inStructuredNode <- ioe.getStatement.getSourceTargetOrOwnerSAN,
			activity <- ioe.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			argument <- Sequence{ip},
			result <- op
		),		
		
		ip : UML!InputPin (
			name <- 'objectInput'
		),
		of2	:	UML!ObjectFlow (
			name <- 'fromOperandToCallBehaviorInput',
			source <- ioe.getSourceForObjectFlow(),
			inStructuredNode <- ioe.getStatement.getSourceTargetOrOwnerSAN,
			activity <- ioe.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- ip
		),
		
		op	:	UML!OutputPin (
			name <- 'resultCallBehaviorOutput'	
		)	
}

rule postfixOperatorExpression extends operatorexpression{
	from
		ioe	:	JAVA!PostfixExpression  (ioe.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration)
				and (ioe.notInInitializerOrFieldOrEnum and ioe.notInAnnotation)	
		)
	to
		cb	:	UML!CallBehaviorAction()	
}

rule prefixOperatorExpression extends operatorexpression{
	from
		ioe	:	JAVA!PrefixExpression  (ioe.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration)	
				and (ioe.notInInitializerOrFieldOrEnum and ioe.notInAnnotation)	
		)
	to
		cb	:	UML!CallBehaviorAction()
}

rule infixOperatorExpression {
	from
		ioe	:	JAVA!InfixExpression ((Sequence{'==','!='}->excludes(ioe.operator.toString()))  
										and (ioe.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration))	
										and (ioe.notInInitializerOrFieldOrEnum and ioe.notInAnnotation)	
		)
	to
		cb	:	UML!CallBehaviorAction(	
			behavior <- ioe.getBehavior,
			name <- ioe.operator.toString(),
			inStructuredNode <- ioe.getStatement.getSourceTargetOrOwnerSAN,
			activity <- ioe.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			argument <- Sequence{ip, inputPinSecondRight},
			result <- op
		),
		
		ip : UML!InputPin (
			name <- 'first'
		),
		of1	:	UML!ObjectFlow (
			name <- 'fromLeftOperandToCallBehaviorAction',
			source <- ioe.getSourceForObjectFlow(),			
			inStructuredNode <- ioe.getStatement.getSourceTargetOrOwnerSAN,
			activity <- ioe.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- ip
		),
		
		inputPinSecondRight	: UML!InputPin (
			name <- 'second'
		),
		of2	:	UML!ObjectFlow (
			name <- 'fromRightOperandToCallBehaviorAction',
			source <- ioe.getSourceForObjectFlowRightOperand(),
			inStructuredNode <- ioe.getStatement.getSourceTargetOrOwnerSAN,
			activity <- ioe.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- inputPinSecondRight
		),
		
		op	:	UML!OutputPin (
			name <- 'resultCallBehaviorActionOutput'
		)
}

rule equalOperatorExpression{
	from
		ioe	:	JAVA!InfixExpression ((Sequence{'=='}->includes(ioe.operator.toString())) 
			and (ioe.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration))	
			and (ioe.notInInitializerOrFieldOrEnum and ioe.notInAnnotation)	
		)
	to
		ti	:	UML!TestIdentityAction(
			name <- ioe.operator.toString(),
			inStructuredNode <- ioe.getStatement.getSourceTargetOrOwnerSAN,
			activity <- ioe.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			first <- ip,
			second <- ipr,
			result <- op
		),
		ip	:	UML!InputPin (
			name <- 'first'
		),
		ipr	:	UML!InputPin (
			name <- 'second'
		),
		op	:	UML!OutputPin (
			name <- 'resultTestIdentityActionOutput'	
		)
	do{
		thisModule.resolveTemp(ioe.leftOperand.getVarAccessExpression, 'ob').name
			<- 	if not thisModule.resolveTemp(ioe.leftOperand.getVarAccessExpression, 'ob').oclIsUndefined() then
					'fromLeftOperandToTestIdentityAction'
				else OclUndefined endif;
		thisModule.resolveTemp(ioe.leftOperand.getVarAccessExpression, 'ob').target
			<- 	if not thisModule.resolveTemp(ioe.leftOperand.getVarAccessExpression, 'ob').oclIsUndefined() then
					ip
				else OclUndefined endif;
		thisModule.resolveTemp(ioe.rightOperand.getVarAccessExpression, 'ob').name
			<- 	if not thisModule.resolveTemp(ioe.rightOperand.getVarAccessExpression, 'ob').oclIsUndefined() then
					'fromRightOperandToTestIdentityAction'
				else OclUndefined endif;
		thisModule.resolveTemp(ioe.rightOperand.getVarAccessExpression, 'ob').target
			<- 	if not thisModule.resolveTemp(ioe.rightOperand.getVarAccessExpression, 'ob').oclIsUndefined() then
					ipr
				else OclUndefined endif;
	}
}

rule notEqualOperatorExpression {
	from
		ioe	:	JAVA!InfixExpression ((Sequence{'!='}->includes(ioe.operator.toString())) 
			and (ioe.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration))
			and (ioe.notInInitializerOrFieldOrEnum and ioe.notInAnnotation)	
		)
	to
		cb	:	UML!TestIdentityAction(
			name <- ioe.operator.toString(),
			inStructuredNode <-if (ioe.refImmediateComposite().isInMethodOrConstructor) then
									ioe.getStatement.refImmediateComposite().getSourceTargetOrOwnerSAN
								else
									ioe.getStatement.getSourceTargetOrOwnerSAN
								endif,	
			activity <- if (ioe.refImmediateComposite().isInMethodOrConstructor) then
							ioe.getStatement.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
						else
							ioe.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN
						endif,
			first <- ip,
			second <- ipr,
			result <- op
		),
		
		ip	:	UML!InputPin (
			incoming <- of1,
			name <- 'first'
		),
		of1	:	UML!ObjectFlow (
			name <- 'fromLeftOperandToTestIdentityAction',
			source <- 	if (ioe.leftOperand.isAccessExpression) then
							thisModule.resolveTemp(ioe.leftOperand.getVarAccessExpression, 'apn')
						else 	
							ioe.leftOperand.getStatement.getSourceTargetOrOwnerSAN
						endif,		
			target <- ip,
			activity <- ioe.getOwningMethod
		),
		
		ipr	:	UML!InputPin (
			incoming <- of2,
			name <- 'second'
		),
		of2	:	UML!ObjectFlow (
			name <- 'fromRightOperandToTestIdentityAction',
			source <- 	if (ioe.rightOperand.isAccessExpression) then
							thisModule.resolveTemp(ioe.rightOperand.getVarAccessExpression, 'apn')
					  	else 
							ioe.rightOperand.getStatement.getSourceTargetOrOwnerSAN
						endif,	
			target <- ipr,
			activity <- ioe.getOwningMethod
		),
		
		op	:	UML!OutputPin (
			name <- 'resultTestIdentityActionOutput'	
		)
}


rule typeCastExpression {
	from 
		tce	:	JAVA!CastExpression (not tce.type.type.oclIsKindOf(JAVA!PrimitiveType)
			and (tce.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration))
			and (tce.notInInitializerOrFieldOrEnum and tce.notInAnnotation)	
		)
	to
		t :	UML!StructuredActivityNode (
			name <- 'cast to '+tce.type.type.name,
			inStructuredNode <- if (tce.refImmediateComposite().oclIsKindOf(JAVA!ParenthesizedExpression)) then 
									tce.refImmediateComposite()
								else
									tce.getStatement.getSourceTargetOrOwnerSAN
								endif,
			activity <- tce.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			edge <- of2,
			structuredNodeInput <- Sequence{ip},
			structuredNodeOutput <-  op
		),
		
		ip : UML!InputPin (
			name <- 'structuredNodeInput'
		),
		of	:	UML!ObjectFlow (
			name <- 'fromActivityNodeToPrecedingStructuredActivityNode',
			source <- 	tce,
			inStructuredNode <-  if (tce.refImmediateComposite().oclIsKindOf(JAVA!ParenthesizedExpression)) then 
									tce.refImmediateComposite()
								else
									tce.getStatement.getSourceTargetOrOwnerSAN
								endif,	
			activity <- tce.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- ip
		),
		
		cf	:	UML!ControlFlow (
			name <- 'fromActivityNodeToStructuredActivityNode',
			source <- tce,
			target <- t,
			inStructuredNode <-  if (tce.refImmediateComposite().oclIsKindOf(JAVA!ParenthesizedExpression)) then 
									tce.refImmediateComposite()
								else
									tce.getStatement.getSourceTargetOrOwnerSAN
								endif,
			activity <- tce.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		
		of2	:	UML!ObjectFlow (
			name <- 'InternalStructuredActivityNodeObjectFlow',
			source <- ip,
			target <- op
		),
		
		op	:	UML!OutputPin (
			name <- 'internalStructuredActivityNodeOutput',
			type <- if (not tce.type.type.oclIsKindOf(JAVA!ArrayType))then
						tce.type.type.excludeUnresolvedTypeDec
					else 
						tce.type.type.elementType.type.excludeUnresolvedTypeDec 
					endif
		)
}


rule numericCastExpression {
	from 
		tce	:	JAVA!CastExpression (
				tce.isANumericCast
				and (tce.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration))
				and (tce.notInInitializerOrFieldOrEnum and tce.notInAnnotation)
		)
	to
		san :	UML!CallBehaviorAction (
			name <- 'to '+tce.type.type.name,
			inStructuredNode <-  if (tce.refImmediateComposite().oclIsKindOf(JAVA!ParenthesizedExpression)) then 
									tce.refImmediateComposite()
								else
									tce.getStatement.getSourceTargetOrOwnerSAN
								endif,
			activity <- tce.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			argument <- Sequence{ip},
			result <- op
		),
		
		ip	:	UML!InputPin (
			name <- 'CallBehaviorActionInput'
		),
		of	:	UML!ObjectFlow (
			name <- 'fromExpressionOutputToCallBehaviorAction',
			source <- thisModule.resolveTemp(tce.expression, 'op'),
			inStructuredNode <-  if (tce.refImmediateComposite().oclIsKindOf(JAVA!ParenthesizedExpression)) then 
									tce.refImmediateComposite()
								else
									tce.getStatement.getSourceTargetOrOwnerSAN
								endif,
			activity <- tce.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- ip				
		),
		
		op	:	UML!OutputPin (
			name <- 'resultCallBehaviorActionOutput',
			type <- tce.type.type.excludeUnresolvedTypeDec
		)
}

rule instanceOf {
	from 
		tce	:	JAVA!InstanceofExpression(	tce.notInInitializerOrFieldOrEnum 
											and tce.notInAnnotation)
	to
		san :	UML!ReadIsClassifiedObjectAction (
			name <- 'instanceOf ' + tce.rightOperand.type.name,
			inStructuredNode <-  if (tce.refImmediateComposite().oclIsKindOf(JAVA!ParenthesizedExpression)) then 
									tce.refImmediateComposite()
								else
									if (tce.refImmediateComposite().oclIsKindOf(JAVA!Statement)) then
										tce.refImmediateComposite().getSourceTargetOrOwnerSAN
									else
										tce.getStatement.refImmediateComposite().getSourceTargetOrOwnerSAN
									endif	
								endif,
			activity <- tce.getStatement.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			object <- ip,
			result <- op,
			classifier <- tce.rightOperand.type.excludeUnresolvedTypeDec
		),
		
		ip	:	UML!InputPin (
			name <- 'instanceOf ' + tce.rightOperand.type.name + '_object'
		),
		
		op : UML!OutputPin (
			name <- 'instanceOf ' + tce.rightOperand.type.name + '_result'
		)
	do{
		thisModule.resolveTemp(tce.getOwningMethod, 'ob').name
			<- 	if not thisModule.resolveTemp(tce.getOwningMethod, 'ob').oclIsUndefined() then
					'fromParametersToReadIsClassifiedObjectAction'
				else OclUndefined endif;
		thisModule.resolveTemp(tce.getOwningMethod, 'ob').name
			<- 	if not thisModule.resolveTemp(tce.getOwningMethod, 'ob').oclIsUndefined() then
					'fromReadIsClassifiedObjectActionToActivityParameterNode'
				else OclUndefined endif;
		if thisModule.resolveTemp(tce.getOwningMethod, 'ob').oclIsUndefined() then
			thisModule.createFlowsForInstanceOfExpress(tce, san)
		else OclUndefined endif;	
	}	
}

rule createFlowsForInstanceOfExpress(tce : JAVA!InstanceofExpression, san :	UML!ReadIsClassifiedObjectAction){
	to		
		controlFlow : UML!ControlFlow(
			name <- 'fromInitialNodeToInternalCurrent',
			inStructuredNode <- tce.getStatement.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- tce.getStatement.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			source <- thisModule.resolveTemp(tce.getStatement.refImmediateComposite(), 'init'),
			target <- tce.refImmediateComposite().getSourceTargetOrOwnerSAN
		)
	do{
		controlFlow;
	}
}

rule unresolvedItemAccess {
	from
		s	:	JAVA!UnresolvedItemAccess(
			not s.getStatement.oclIsUndefined()	
		)
	to
		t	:	UML!OpaqueAction(
			name <- 'UnresolvedItemAccess_'+s.element.name,
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN
		)
}

rule unresolvedAnnotationDeclaration{
	from
		s	:	JAVA!UnresolvedAnnotationDeclaration
	to
		t	:	UML!Class(
			name <- s.name + '-unsupported'	
		)
	do{
		thisModule.getTypeDec <- thisModule.getTypeDec -> including(s, t);	
	}	
}

rule wildCardType{
	from
		s	:	JAVA!WildCardType
	to
		t	:	UML!Class(
			name <- s.name + '-unsupported'	
		)
	do{
		thisModule.getTypeDec <- thisModule.getTypeDec -> including(s, t);	
	}	
}

rule PrimitiveType {
	from
		s	:	JAVA!PrimitiveType
	to
		t	:	UML!PrimitiveType(
			name <- s.name	
		)
}

rule annotationTypeDeclaration{
	from
		s	:	JAVA!AnnotationTypeDeclaration
	to
		t	:	UML!Class(
			name <- s.name + '-unsupported'	
		)
	do{
		thisModule.getTypeDec <- thisModule.getTypeDec -> including(s, t);	
	}	
}

rule stringLiteral2ValueSpecification {
	from
		sl	:	JAVA!StringLiteral (if (sl.notInAnnotation) then 
									sl.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration) 
									else false endif
		)
	to
		vsa	:	UML!ValueSpecificationAction (
			name <- 'valueSpecificationAction',
			result <- op,
			value <- vs,
			inStructuredNode <- sl.getStatement.getSourceTargetOrOwnerSAN,
			activity <- sl.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		vs	:	UML!LiteralString(
			name <- 'literalString',
			value <- sl.escapedValue.regexReplaceAll('"', '')
		),	
		op	:	UML!OutputPin (
			name <- 'resultValueSpecificationActionOutput'
		)
	do{
		thisModule.resolveTemp(sl.getStatement, 'initialControlFlow').name 
			<- 	sl.setControlFlowParam('name', 'initialControlFlow', 'fromInitialNodeToVSA');
		thisModule.resolveTemp(sl.getStatement, 'initialControlFlow').target 
			<- sl.setControlFlowParam('target', 'initialControlFlow', vsa);		
		thisModule.resolveTemp(sl.getStatement, 'finalControlFlow').name 
			<- sl.setControlFlowParam('name', 'finalControlFlow', 'fromInitialNodeToVSA');
		thisModule.resolveTemp(sl.getStatement, 'finalControlFlow').target 
			<- sl.setControlFlowParam('target', 'finalControlFlow', vsa);
	}	
}

rule charLiteral2ValueSpecification {
	from
		cl	:	JAVA!CharacterLiteral ( if (cl.notInAnnotation) then 
										cl.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration)
										else false endif
			)
	to
		vsa	:	UML!ValueSpecificationAction (
			name <- 'valueSpecificationAction',
			result <- op,
			value <- vs,
			inStructuredNode <- cl.getStatement.getSourceTargetOrOwnerSAN,
			activity <- cl.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		vs	:	UML!LiteralString(
			name <- 'literalString',
			value <- cl.escapedValue.regexReplaceAll('"', '')
		),
		op	:	UML!OutputPin (
			name <- 'resultValueSpecificationActionOutput'
		)
	do{
		thisModule.resolveTemp(cl.getStatement, 'initialControlFlow').name 
			<- 	cl.setControlFlowParam('name', 'initialControlFlow', 'fromInitialNodeToVSA');
		thisModule.resolveTemp(cl.getStatement, 'initialControlFlow').target 
			<- cl.setControlFlowParam('target', 'initialControlFlow', vsa);		
		thisModule.resolveTemp(cl.getStatement, 'finalControlFlow').name 
			<- cl.setControlFlowParam('name', 'finalControlFlow', 'fromInitialNodeToVSA');
		thisModule.resolveTemp(cl.getStatement, 'finalControlFlow').target 
			<- cl.setControlFlowParam('target', 'finalControlFlow', vsa);
	}		
}

rule Booleanliteral2ValueSpecification {
	from
		bl	:	JAVA!BooleanLiteral (
			bl.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration)
			and bl.notInAnnotation
		)
	to
		vsa	:	UML!ValueSpecificationAction (
			name <- 'valueSpecificationAction',
			result <- op,
			value <- vs,
			inStructuredNode <- bl.getStatement.getSourceTargetOrOwnerSAN,
			activity <- bl.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		vs	:	UML!LiteralBoolean(
			name <- 'literalBoolean',
			value <- bl.value
		),
		op	:	UML!OutputPin (
			name <- 'resultValueSpecificationActionOutput'	
		)
	do{
		thisModule.resolveTemp(bl.getStatement, 'initialControlFlow').name 
			<- 	bl.setControlFlowParam('name', 'initialControlFlow', 'fromInitialNodeToVSA');
		thisModule.resolveTemp(bl.getStatement, 'initialControlFlow').target 
			<- bl.setControlFlowParam('target', 'initialControlFlow', vsa);		
		thisModule.resolveTemp(bl.getStatement, 'finalControlFlow').name 
			<- bl.setControlFlowParam('name', 'finalControlFlow', 'fromInitialNodeToVSA');
		thisModule.resolveTemp(bl.getStatement, 'finalControlFlow').target 
			<- bl.setControlFlowParam('target', 'finalControlFlow', vsa);
	}	
}

rule numberLiteral2ValueSpecification {
	from
		nl	:	JAVA!NumberLiteral (
			(nl.tokenValue.indexOf('.')=-1) 
			and nl.notInInitializerOrFieldOrEnum				
			and nl.notInAnnotation
		)
	to 
		vsa	:	UML!ValueSpecificationAction (
			name <- nl.toString(),
			result <- op,
			value <-vs,
			inStructuredNode <- nl.getStatement.getSourceTargetOrOwnerSAN,
			activity <- nl.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		vs	:	UML!LiteralInteger(
			name <- 'literalInteger',
			value <- nl.tokenValue.regexReplaceAll('[A-Za-z]', '').toInteger()
		),
		op	:	UML!OutputPin (
			name <- 'resultValueSpecificationActionOutput'	
		)
	do{
		thisModule.resolveTemp(nl.getStatement, 'initialControlFlow').name 
			<- 	nl.setControlFlowParam('name', 'initialControlFlow', 'fromInitialNodeToVSA');
		thisModule.resolveTemp(nl.getStatement, 'initialControlFlow').target 
			<- nl.setControlFlowParam('target', 'initialControlFlow', vsa);		
		thisModule.resolveTemp(nl.getStatement, 'finalControlFlow').name 
			<- nl.setControlFlowParam('name', 'finalControlFlow', 'fromInitialNodeToVSA');
		thisModule.resolveTemp(nl.getStatement, 'finalControlFlow').target 
			<- nl.setControlFlowParam('target', 'finalControlFlow', vsa);
	}	
}

rule realNumberLiteral2ValueSpecification {
	from
		nl	:	JAVA!NumberLiteral (
			(not (nl.tokenValue.indexOf('.')=-1)  
			and	nl.notInInitializerOrFieldOrEnum)
			and nl.notInAnnotation
		)
	to 
		vsa	:	UML!ValueSpecificationAction (
			name <- nl.toString(),
			result <- op,
			value <-vs,
			inStructuredNode <- nl.getStatement.getSourceTargetOrOwnerSAN,
			activity <- nl.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		vs	:	UML!LiteralReal(
			name <- 'literalReal',
			value <- nl.tokenValue.regexReplaceAll('[A-Za-z]', '').toReal()
		),
		op	:	UML!OutputPin (
			name <- 'resultValueSpecificationActionOutput'	
		)
	do{
		thisModule.resolveTemp(nl.getStatement, 'initialControlFlow').name 
			<- 	nl.setControlFlowParam('name', 'initialControlFlow', 'fromInitialNodeToVSA');
		thisModule.resolveTemp(nl.getStatement, 'initialControlFlow').target 
			<- nl.setControlFlowParam('target', 'initialControlFlow', vsa);		
		thisModule.resolveTemp(nl.getStatement, 'finalControlFlow').name 
			<- nl.setControlFlowParam('name', 'finalControlFlow', 'fromInitialNodeToVSA');
		thisModule.resolveTemp(nl.getStatement, 'finalControlFlow').target 
			<- nl.setControlFlowParam('target', 'finalControlFlow', vsa);
	}	
}

rule nullLiteral2ValueSpecification {
	from
		nl	:	JAVA!NullLiteral (
			nl.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration)
			and not nl.refImmediateComposite().oclIsKindOf(JAVA!MethodInvocation)
			and nl.notInAnnotation
		)
	to 
		vsa	:	UML!ValueSpecificationAction (
			name <- nl.toString(),
			result <- op,
			value <-OclUndefined,
			inStructuredNode <- nl.getStatement.getSourceTargetOrOwnerSAN,
			activity <- nl.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		op	:	UML!OutputPin (
			name <- 'resultValueSpecificationActionOutput'
		)
	do{
		thisModule.resolveTemp(nl.getStatement, 'initialControlFlow').name 
			<- 	nl.setControlFlowParam('name', 'initialControlFlow', 'fromInitialNodeToVSA');
		thisModule.resolveTemp(nl.getStatement, 'initialControlFlow').target 
			<- nl.setControlFlowParam('target', 'initialControlFlow', vsa);		
		thisModule.resolveTemp(nl.getStatement, 'finalControlFlow').name 
			<- nl.setControlFlowParam('name', 'finalControlFlow', 'fromInitialNodeToVSA');
		thisModule.resolveTemp(nl.getStatement, 'finalControlFlow').target 
			<- nl.setControlFlowParam('target', 'finalControlFlow', vsa);
	}	
}

---Lazy rules
unique lazy rule createArgumentNotPrimitiv {
	from
		a	:	JAVA!Expression
	to
		ip : UML!InputPin (
			name <- 'objectInput',
			incoming <- of2
		),
		of2	:	UML!ObjectFlow (
			name <- 'fromExpressionOutput',
			source <- thisModule.resolveTemp(a, 'op'),
			activity <- if a.refImmediateComposite().method.oclIsKindOf(JAVA!UnresolvedMethodDeclaration)then
							if  a.refImmediateComposite().method.getCorrespondingDec.oclIsTypeOf(JAVA!MethodDeclaration)then
								a.refImmediateComposite().method.getCorrespondingDec
							else a.refImmediateComposite().method									
							endif
						else a.getOwningMethod						
						endif,
			target <- ip
		),
		cf	:	UML!ControlFlow (
			name <- 'fromExpressionOutputToStatement',
			source <- thisModule.resolveTemp(a, 'op'),
			activity <- if a.refImmediateComposite().method.oclIsKindOf(JAVA!UnresolvedMethodDeclaration)then
							if  not a.refImmediateComposite().method.getCorrespondingDec.oclIsTypeOf(JAVA!MethodDeclaration)then
								a.refImmediateComposite().method
							else a.refImmediateComposite().method.getCorrespondingDec endif
						else a.getOwningMethod endif,
			target <- 	if (a.refImmediateComposite().getStatement.oclIsKindOf(JAVA!ReturnStatement))then
							if (not a.refImmediateComposite().getStatement.isReturnStateGeneratingObjectFlow)then
								thisModule.resolveTemp(a.refImmediateComposite().getStatement, 'co')
							else OclUndefined endif	
						else a.refImmediateComposite() endif
		)
}

unique lazy rule createArgument {
	from
		a	:	JAVA!Expression
	to
		ip : UML!InputPin (
			name <- 'objectInput',
			incoming <- of2
		),
		of2	:	UML!ObjectFlow (
			name <- 'fromExpressionOutputToStatement',
			source <- thisModule.resolveTemp(a, 'op'),
			inStructuredNode <- a.getStatement.getSourceTargetOrOwnerSAN,
			activity <- a.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- ip
		)
}

unique lazy rule Parameters2ActivityParameter{
	from
		param	:	JAVA!SingleVariableDeclaration 
	to	
		paramAct	:	UML!Parameter(
			name <- param.name,
			type <-	if (param.type.type.oclIsKindOf(JAVA!ParameterizedType)) then
						param.type.type.typeArguments ->first().type.excludeUnresolvedTypeDec
					else 
						if (param.type.type.oclIsKindOf(JAVA!ArrayType)) then
							param.type.type.elementType.type.excludeUnresolvedTypeDec
						else
							param.type.type.excludeUnresolvedTypeDec
						endif
					endif,
			lower <- if (param.type.type.oclIsKindOf(JAVA!ArrayType)) then
						1
					else 0 endif,			
			upper <-	if (param.type.isAList or param.type.isASet
								or param.type.type.oclIsKindOf(JAVA!ArrayType)or param.usageInVariableAccess 
									-> select(param | param.refImmediateComposite().isALoopStatement)
									-> notEmpty()
						)then
							-1
						else 1	endif
		)
}


rule arrayToClass {
	from
		arrayType	:	JAVA!ArrayType
	to
		umlClass	:	UML!Class(
			name <- arrayType.elementType.type.name+'[]',
			ownedAttribute <- umlProperty			
		), 
		umlProperty	:	UML!Property(
			type <- if (arrayType.elementType.type.oclIsKindOf(JAVA!TypeParameter)) then
							arrayType.elementType.type.excludeUnresolvedTypeDec
					else 
						arrayType.elementType.type.excludeUnresolvedTypeDec
					endif,
			name <- 'type'		
		)
}

rule typeParameterToClass {
	from 
		jBodyDec : JAVA!TypeParameter
	to 
		umlElement : UML!Class( 
			name <- jBodyDec.name
		)
}

unique lazy rule createEmptyElse{
	from
		ifs	:	JAVA!IfStatement
	to
		t : UML!StructuredActivityNode(
			inStructuredNode <- ifs,
			name <- 'Empty Else'
		)
}

unique lazy rule createListGetFumlLib{
	from
		s	:	JAVA!ExpressionStatement
	to
		listGet : UML!OpaqueBehavior(
			name <- 'ListGet',
			ownedParameter <- Sequence{list, index, result}
		),
		list : UML!Parameter(
			name <- 'list',	
			lower <- 0,			
			upper <- -1
		),
		index : UML!Parameter(
			name <- 'index',
			lower <- 0,			
			upper <- 1
		),
		result : UML!Parameter(
			name <- 'result',
			lower <- 0,			
			upper <- 1
		)
	do{
		thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier 
			<- thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier -> append(listGet);
	}	
}

unique lazy rule createIntegerMinusFumlLib{
	from
		s	:	JAVA!ExpressionStatement
	to
		integerMinus : UML!OpaqueBehavior(
			name <- 'IntegerMinus',
			ownedParameter <- Sequence{x, y, result}			
		),
		x : UML!Parameter(
			name <- 'x',
			lower <- 0,			
			upper <- 1
		),
		y : UML!Parameter(
			name <- 'y',
			lower <- 0,			
			upper <- 1
		),
		result : UML!Parameter(
			name <- 'result',
			lower <- 0,			
			upper <- 1
		)
	do{
		thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier 
			<- thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier -> append(integerMinus);
	}	
}

unique lazy rule createIntegerPlusFumlLib{
	from
		s	:	JAVA!ExpressionStatement
	to
		integerPlus : UML!OpaqueBehavior(
			name <- 'IntegerPlus',
			ownedParameter <- Sequence{x, y, result}
		),
		x : UML!Parameter(
			name <- 'x',
			lower <- 0,			
			upper <- 1
		),
		y : UML!Parameter(
			name <- 'y',
			lower <- 0,			
			upper <- 1
		),
		result : UML!Parameter(
			name <- 'result',
			lower <- 0,			
			upper <- 1
		)
	do{
		thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier 
			<- thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier -> append(integerPlus);
	}
}

unique lazy rule createIntegerTimesFumlLib{
	from
		s	:	JAVA!ExpressionStatement
	to
		integerTimes : UML!OpaqueBehavior(
			name <- 'IntegerTimes',
			ownedParameter <- Sequence{x, y, result}
		),
		x : UML!Parameter(
			name <- 'x',
			lower <- 0,			
			upper <- 1
		),
		y : UML!Parameter(
			name <- 'y',
			lower <- 0,			
			upper <- 1
		),
		result : UML!Parameter(
			name <- 'result',
			lower <- 0,			
			upper <- 1
		)
	do{
		thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier 
			<- thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier -> append(integerTimes);
	}	
}

unique lazy rule createIntegerDivideFumlLib{
	from
		s	:	JAVA!ExpressionStatement
	to
		integerDivide : UML!OpaqueBehavior(
			name <- 'IntegerDivide',
			ownedParameter <- Sequence{x, y, result}
		),
		x : UML!Parameter(
			name <- 'x',
			lower <- 0,			
			upper <- 1
		),
		y : UML!Parameter(
			name <- 'y',
			lower <- 0,			
			upper <- 1
		),
		result : UML!Parameter(
			name <- 'result',
			lower <- 0,			
			upper <- 1
		)
	do{
		thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier 
			<- thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier -> append(integerDivide);
	}	
}

unique lazy rule createIntegerLessFumlLib{
	from
		s	:	JAVA!ExpressionStatement
	to
		integerLess : UML!OpaqueBehavior(
			name <- 'IntegerLess',
			ownedParameter <- Sequence{x, y, result}
		),
		x : UML!Parameter(
			name <- 'x',
			lower <- 0,			
			upper <- 1
		),
		y : UML!Parameter(
			name <- 'y',
			lower <- 0,			
			upper <- 1
		),
		result : UML!Parameter(
			name <- 'result',
			lower <- 0,			
			upper <- 1
		)
	do{
		thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier 
			<- thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier -> append(integerLess);
	}
}

unique lazy rule createIntegerGreaterFumlLib{
	from
		s	:	JAVA!ExpressionStatement
	to
		integerGreater : UML!OpaqueBehavior(
			name <- 'IntegerGreater',
			ownedParameter <- Sequence{x, y, result}
		),
		x : UML!Parameter(
			name <- 'x',
			lower <- 0,			
			upper <- 1	
		),
		y : UML!Parameter(
			name <- 'y',
			lower <- 0,			
			upper <- 1
		),
		result : UML!Parameter(
			name <- 'result',
			lower <- 0,			
			upper <- 1
		)
	do{
		thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier 
			<- thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier -> append(integerGreater);
	}
}

unique lazy rule createIntegerLessOrEqualsFumlLib{
	from
		s	:	JAVA!ExpressionStatement
	to
		integerLessOrEquals : UML!OpaqueBehavior(
			name <- 'IntegerLessOrEquals',
			ownedParameter <- Sequence{x, y, result}
		),
		x : UML!Parameter(
			name <- 'x',
			lower <- 0,			
			upper <- 1
		),
		y : UML!Parameter(
			name <- 'y',
			lower <- 0,			
			upper <- 1
		),
		result : UML!Parameter(
			name <- 'result',
			lower <- 0,			
			upper <- 1
		)
	do{
		thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier 
			<- thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier -> append(integerLessOrEquals);
	}	
}

unique lazy rule createIntegerGreaterOrEqualsFumlLib{
	from
		s	:	JAVA!ExpressionStatement
	to
		integerGreaterOrEquals : UML!OpaqueBehavior(
			name <- 'IntegerGreaterOrEquals',
			ownedParameter <- Sequence{x, y, result}
		),
		x : UML!Parameter(
			name <- 'x',
			lower <- 0,			
			upper <- 1
		),
		y : UML!Parameter(
			name <- 'y',
			lower <- 0,			
			upper <- 1
		),
		result : UML!Parameter(
			name <- 'result',
			lower <- 0,			
			upper <- 1
		)
	do{
		thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier 
			<- thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier -> append(integerGreaterOrEquals);
	}
}


rule createObjectFlowToVSA(s : JAVA!ExpressionStatement, insertAtIP : UML!InputPin){
	to
		valueSpecActionOF : UML!ObjectFlow(
			name <- 'objectFlowFromValueSpecificationAction',
			source <- valueSpecAction,
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- insertAtIP
		),
		valueSpecAction	: UML!ValueSpecificationAction(
			name <- 'valueSpecificationAction',
			value <- literUnlimNatur,
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		literUnlimNatur : UML!LiteralUnlimitedNatural(
			name <- 'literalUnlimitedNatural',
			value <- -1
		)
	do{
		valueSpecActionOF;
	}
}

rule createObjectFlowToNode(s : JAVA!ExpressionStatement, insertAtIP : UML!InputPin){
	to
		insertAtOF : UML!ObjectFlow(
			name <- 'objectFlowFromNode',
			source <- 	s.expression.arguments 
							-> reject(arg | arg.isALiteral)
							-> select(arg | arg.getVarAccessExpression.name = 'insertAt')
							-> collect(arg | arg.getVarAccessExpression)
							-> flatten()
							-> first(),
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- insertAtIP
		)
	do{
		insertAtOF;
	}
}

rule fieldDeclarationToProperty{
	from
		fieldDec : JAVA!FieldDeclaration
	to
		struct : UML!Property(
			name <- fieldDec.getFieldName,
			type <- if (fieldDec.getFieldType.oclIsKindOf(JAVA!ArrayType)) then
							fieldDec.getFieldType
					else if (fieldDec.getFieldType.oclIsKindOf(JAVA!TypeParameter)) then
								fieldDec.getFieldType
						 else 
						 	if (fieldDec.getFieldType.oclIsKindOf(JAVA!ParameterizedType)) then
								fieldDec.getFieldType.typeArguments ->first().type.excludeUnresolvedTypeDec
							else fieldDec.getFieldType endif	
						 endif
					endif,
			lower <- if (fieldDec.getFieldType.oclIsKindOf(JAVA!ArrayType)) then
						1
					else 0 endif,			
			upper <-	if (fieldDec.isAList or fieldDec.isASet
								or fieldDec.getFieldType.oclIsKindOf(JAVA!ArrayType))then
							-1
						else 1	endif,					
					
			isUnique <-  fieldDec.isASet,
			isOrdered <- fieldDec.isAList or fieldDec.getFieldType.oclIsKindOf(JAVA!ArrayType),
			visibility <- fieldDec.getFieldVisibility
							
		)
	do{
		if (not thisModule.resolveTemp(fieldDec.getInstanciedClass, 't').oclIsUndefined())then
			thisModule.resolveTemp(fieldDec.getInstanciedClass, 't').refSetValue('ownedAttribute', struct)
		else OclUndefined endif;
	}	
}

unique lazy rule createProperty{
	from
		singleAccess : JAVA!ASTNode
	to
		struct : UML!Property(
			name <- if (singleAccess.oclIsKindOf(JAVA!FieldDeclaration))then
						singleAccess.getFieldName
					else	
						if (singleAccess.oclIsKindOf(JAVA!InfixExpression)) then
							if (singleAccess.leftOperand.oclIsKindOf(JAVA!UnresolvedItemAccess)) then
								singleAccess.leftOperand.element.name
							else singleAccess.leftOperand.name endif
						else
							if (not singleAccess.isALiteral and not singleAccess.oclIsKindOf(JAVA!TypeAccess))then
								singleAccess.variable.name
							else 
								if (singleAccess.type.oclIsKindOf(JAVA!ClassDeclaration))then
									singleAccess.type.name
								else							
									singleAccess.type.type.name 
								endif
							endif	
						endif
					endif,
			type <- if (singleAccess.oclIsKindOf(JAVA!FieldDeclaration))then
						if (singleAccess.getFieldType.oclIsKindOf(JAVA!ArrayType)) then
									singleAccess.getFieldType
							else if (singleAccess.getFieldType.oclIsKindOf(JAVA!TypeParameter)) then
										singleAccess.getFieldType
								 else 
								 	if (singleAccess.getFieldType.oclIsKindOf(JAVA!ParameterizedType)) then
										singleAccess.getFieldType.typeArguments ->first().type.excludeUnresolvedTypeDec
									else singleAccess.getFieldType endif	
								 endif
							endif
					else	
						if (singleAccess.getVariableType.oclIsKindOf(JAVA!ParameterizedType)) then 
							singleAccess.getVariableType.typeArguments -> first().type.excludeUnresolvedTypeDec
						else 
							if (singleAccess.getVariableType.oclIsKindOf(JAVA!ArrayType)) then
								singleAccess.getVariableType.elementType.type.excludeUnresolvedTypeDec
							else
								singleAccess.getVariableType.excludeUnresolvedTypeDec
							endif	
						endif
					endif,
			lower <-if (singleAccess.oclIsKindOf(JAVA!FieldDeclaration))then
						if (singleAccess.getFieldType.oclIsKindOf(JAVA!ArrayType)) then
							1
						else 0 endif
					else
						if (singleAccess.getVariableType.oclIsKindOf(JAVA!ArrayType)) then
							1
						else 0 endif
					endif,
			upper <-	if (singleAccess.isAList or singleAccess.isASet) then
							-1
						else 
							if singleAccess.oclIsKindOf(JAVA!FieldDeclaration)then
								if singleAccess.getFieldType.oclIsKindOf(JAVA!ArrayType) then
									-1
								else 1 endif
							else
								if singleAccess.getVariableType.oclIsKindOf(JAVA!ArrayType) then
									-1
								else 1 endif
							endif
						endif,	
						
			isUnique <-  singleAccess.isASet,
			isOrdered <- singleAccess.isAList or 
							(
								if singleAccess.oclIsKindOf(JAVA!FieldDeclaration)then
									singleAccess.getFieldType.oclIsKindOf(JAVA!ArrayType)
								else 
									singleAccess.getVariableType.oclIsKindOf(JAVA!ArrayType)
								endif
							),
			visibility <- 	if (singleAccess.oclIsKindOf(JAVA!FieldDeclaration))then
								singleAccess.getFieldVisibility
							else
								if (not singleAccess.isALiteral and not singleAccess.oclIsKindOf(JAVA!TypeAccess)
									and not singleAccess.oclIsKindOf(JAVA!InfixExpression))then
									if (singleAccess.variable.oclIsKindOf(JAVA!VariableDeclarationFragment))then
										if (singleAccess.variable.variablesContainer.oclIsKindOf(JAVA!FieldDeclaration))then
											singleAccess.variable.variablesContainer.getFieldVisibility
										else OclUndefined endif		
									else OclUndefined endif	
								else 								
									if (singleAccess.oclIsKindOf(JAVA!InfixExpression)) then
										if (singleAccess.leftOperand.oclIsKindOf(JAVA!MethodInvocation)) then
											if (singleAccess.leftOperand.method.oclIsKindOf(JAVA!MethodDeclaration)) then
												singleAccess.leftOperand.method.modifier.visibility
											else #package endif
										else
											if (singleAccess.leftOperand.oclIsKindOf(JAVA!UnresolvedItemAccess)) then
												#package
											else 
												singleAccess.leftOperand.type.modifier.visibility 
											endif
										endif	
									else
										if (singleAccess.oclIsKindOf(JAVA!TypeAccess) 
											and singleAccess.type.oclIsKindOf(JAVA!ClassDeclaration))then
											singleAccess.type.modifier.visibility
										else
											singleAccess.type.type.modifier.visibility
										endif
									endif
								endif
							endif
		)
	do{
		thisModule.allASTNode <- thisModule.allASTNode -> including(singleAccess, struct);
		if (not thisModule.resolveTemp(singleAccess.getInstanciedClass, 't').oclIsUndefined())then
			thisModule.resolveTemp(singleAccess.getInstanciedClass, 't').refSetValue('ownedAttribute', struct)
		else OclUndefined endif;
	}	
}

unique lazy rule createOutputPin{
	from
		s	:	JAVA!ExpressionStatement, outputPinName : String
	to
		op : UML!OutputPin (
			name <- outputPinName
		)
}

unique lazy rule createStructuredActivityNode{
	from
		otherT :	UML!StructuredActivityNode, sanName : String
	to
		t :	UML!StructuredActivityNode(
			inStructuredNode <- otherT,
			name <- sanName
		)
}

unique lazy rule createActivityFinalNode {
	from
		t : UML!StructuredActivityNode
	to
		final	:	UML!ActivityFinalNode(
			inStructuredNode <- t,
			name <- 'finalNode'
		)
}

--***************Unresolved items***************
rule JUnresolvedItemToUmlClass {
	from 
		jUnresItem : JAVA!UnresolvedItem(
			not jUnresItem.oclIsTypeOf(JAVA!UnresolvedMethodDeclaration)
			and not jUnresItem.oclIsTypeOf(JAVA!UnresolvedLabeledStatement)
			and
			(
				jUnresItem.getCorrespondingDec.oclIsTypeOf(JAVA!ClassDeclaration)
				or
				jUnresItem.getCorrespondingDec.oclIsTypeOf(JAVA!ImportDeclaration)
			)
		)
	to 
		umlNamedElement : UML!Class(
			name <- jUnresItem.name,
			package <- thisModule.createExternalsModel(thisModule.jModelRoot)
		)
}

rule JUnresolvedItemToUmlInterface {
	from 
		jUnresItem : JAVA!UnresolvedItem(
			not jUnresItem.oclIsTypeOf(JAVA!UnresolvedMethodDeclaration)
			and not jUnresItem.oclIsTypeOf(JAVA!UnresolvedLabeledStatement)
			and (jUnresItem.getCorrespondingDec.oclIsTypeOf(JAVA!InterfaceDeclaration))
		)
	to 
		umlNamedElement : UML!Interface(
			name <- jUnresItem.name,
			package <- thisModule.createExternalsModel(thisModule.jModelRoot) 
		)
}

rule JUnresolvedItemToUmlEnum {
	from 
		jUnresItem : JAVA!UnresolvedItem(
			not jUnresItem.oclIsTypeOf(JAVA!UnresolvedMethodDeclaration)
			and not jUnresItem.oclIsTypeOf(JAVA!UnresolvedLabeledStatement)
			and (jUnresItem.getCorrespondingDec.oclIsTypeOf(JAVA!EnumDeclaration))
		)
	to 
		umlNamedElement : UML!Enumeration(
			name <- jUnresItem.name,
			package <- thisModule.createExternalsModel(thisModule.jModelRoot)
		)
}

rule JUnresolvedMethodDecToActivity{
	from 
		construcOrMethodDec : JAVA!UnresolvedMethodDeclaration(
			not construcOrMethodDec.getCorrespondingDec.oclIsKindOf(JAVA!MethodDeclaration)
		)
	to 
		act	:	UML!Activity(
			name <- construcOrMethodDec.name,
			visibility <- construcOrMethodDec.getAbsMethDecVisibility
		),
		
		init	:	UML!InitialNode(
			name <- 'initialNode',
			activity <- act
		),
		icf : UML!ControlFlow(
			name <- 'fromIntialNodeToOpaqueAction',
			activity <- act,
			target <- opaqueAction,
			source <- init 
		),
		
		opaqueAction : UML!OpaqueAction(
			name <- 'OpaqueAction_UnresolvedMethodDelaration',
			activity <- act
		),
		
		final	:	UML!ActivityFinalNode(
			name <- 'finalNode',
			activity <- act
		),
		fcf : UML!ControlFlow(
			name <- 'fromOpaqueActionToFinalNode',
			activity <- act,
			target <- final,
			source <- opaqueAction
		)	
}
